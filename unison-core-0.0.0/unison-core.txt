-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-core
@version 0.0.0

module U.Core.ABT
data ABT f v r
Var :: v -> ABT f v r
Cycle :: r -> ABT f v r
Abs :: v -> r -> ABT f v r
Tm :: f r -> ABT f v r

-- | At each level in the tree, we store the set of free variables and a
--   value of type <tt>a</tt>. Variables are of type <tt>v</tt>.
data Term f v a
Term :: Set v -> a -> ABT f v (Term f v a) -> Term f v a
[freeVars] :: Term f v a -> Set v
[annotation] :: Term f v a -> a
[out] :: Term f v a -> ABT f v (Term f v a)
amap :: (Functor f, Foldable f) => (a -> a') -> Term f v a -> Term f v a'
vmap :: (Functor f, Foldable f, Ord v') => (v -> v') -> Term f v a -> Term f v' a
transform :: (Ord v, Foldable g, Functor g) => (forall a. f a -> g a) -> Term f v a -> Term g v a
transformM :: (Ord v, Monad m, Traversable g) => (forall a. f a -> m (g a)) -> Term f v a -> m (Term g v a)
abs :: Ord v => a -> v -> Term f v a -> Term f v a
var :: a -> v -> Term f v a
cycle :: a -> Term f v a -> Term f v a
tm :: (Foldable f, Ord v) => a -> f (Term f v a) -> Term f v a

-- | `visit f t` applies an effectful function to each subtree of
--   <tt>t</tt> and sequences the results. When <tt>f</tt> returns
--   <a>Nothing</a>, <a>visit</a> descends into the children of the current
--   subtree. When <tt>f</tt> returns `Just t2`, <a>visit</a> replaces the
--   current subtree with <tt>t2</tt>. Thus: `visit (const Nothing) t ==
--   pure t` and `visit (const (Just (pure t2))) t == pure t2`
visit :: (Traversable f, Applicative g, Ord v) => (Term f v a -> Maybe (g (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit' :: (Traversable f, Applicative g, Monad g, Ord v) => (f (Term f v a) -> g (f (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit_ :: (Traversable f, Applicative g, Monad g, Ord v) => (f (Term f v a) -> g ()) -> Term f v a -> g (Term f v a)

-- | <a>visit</a> specialized to the <a>Identity</a> effect.
visitPure :: (Traversable f, Ord v) => (Term f v a -> Maybe (Term f v a)) -> Term f v a -> Term f v a
foreachSubterm :: (Traversable f, Applicative g, Ord v) => (Term f v a -> g b) -> Term f v a -> g [b]
subterms :: (Ord v, Traversable f) => Term f v a -> [Term f v a]
pattern Var' :: v -> Term f v a
pattern Cycle' :: [v] -> Term f v a -> Term f v a
pattern AbsN' :: [v] -> Term f v a -> Term f v a
pattern Tm' :: f (Term f v a) -> Term f v a
unabs :: Term f v a -> ([v], Term f v a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (U.Core.ABT.ABT f v)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (U.Core.ABT.ABT f v)
instance GHC.Base.Functor f => GHC.Base.Functor (U.Core.ABT.ABT f v)
instance (GHC.Show.Show v, GHC.Show.Show r, GHC.Show.Show (f r)) => GHC.Show.Show (U.Core.ABT.ABT f v r)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (U.Core.ABT.Term f v)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (U.Core.ABT.Term f v)
instance GHC.Base.Functor f => GHC.Base.Functor (U.Core.ABT.Term f v)
instance (forall q. GHC.Show.Show q => GHC.Show.Show (f q), GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (U.Core.ABT.Term f v a)

module U.Core.ABT.Var

-- | A class for avoiding accidental variable capture
--   
--   <ul>
--   <li>`Set.notMember (freshIn vs v) vs`: <a>freshIn</a> returns a
--   variable not used in the <a>Set</a></li>
--   </ul>
class Ord v => Var v
freshIn :: Var v => Set v -> v -> v
substsInheritAnnotation :: (Foldable f, Functor f, Var v) => [(v, Term f v b)] -> Term f v a -> Term f v a
substInheritAnnotation :: (Foldable f, Functor f, Var v) => v -> Term f v b -> Term f v a -> Term f v a
subst' :: (Foldable f, Functor f, Var v) => (a -> Term f v a) -> v -> Set v -> Term f v a -> Term f v a

-- | renames <tt>old</tt> to <tt>new</tt> in the given term, ignoring
--   subtrees that bind <tt>old</tt>
rename :: (Foldable f, Functor f, Var v) => v -> v -> Term f v a -> Term f v a
