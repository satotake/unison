-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-core1
@version 0.0.0

module Unison.Blank
loc :: Recorded loc -> loc
nameb :: Blank loc -> Maybe String
data Recorded loc
Placeholder :: loc -> String -> Recorded loc
Resolve :: loc -> String -> Recorded loc
data Blank loc
Blank :: Blank loc
Recorded :: Recorded loc -> Blank loc
instance GHC.Base.Functor Unison.Blank.Recorded
instance GHC.Classes.Ord loc => GHC.Classes.Ord (Unison.Blank.Recorded loc)
instance GHC.Classes.Eq loc => GHC.Classes.Eq (Unison.Blank.Recorded loc)
instance GHC.Show.Show loc => GHC.Show.Show (Unison.Blank.Recorded loc)
instance GHC.Base.Functor Unison.Blank.Blank
instance GHC.Classes.Ord loc => GHC.Classes.Ord (Unison.Blank.Blank loc)
instance GHC.Classes.Eq loc => GHC.Classes.Eq (Unison.Blank.Blank loc)
instance GHC.Show.Show loc => GHC.Show.Show (Unison.Blank.Blank loc)

module Unison.DataDeclaration.ConstructorId
type ConstructorId = Int

module Unison.Hashable
data Token h
Tag :: !Word8 -> Token h
Bytes :: !ByteString -> Token h
Int :: !Int64 -> Token h
Text :: !Text -> Token h
Double :: !Double -> Token h
Hashed :: !h -> Token h
Nat :: !Word64 -> Token h
class Accumulate h
accumulate :: Accumulate h => [Token h] -> h
fromBytes :: Accumulate h => ByteString -> h
toBytes :: Accumulate h => h -> ByteString
accumulateToken :: (Accumulate h, Hashable t) => t -> Token h
accumulate' :: (Accumulate h, Hashable t) => t -> h
class Hashable t
tokens :: (Hashable t, Accumulate h) => t -> [Token h]
class Functor f => Hashable1 f

-- | Produce a hash for an `f a`, given a hashing function for <tt>a</tt>.
--   If there is a notion of order-independence in some aspect of a subterm
--   of <tt>f</tt>, then the first argument (`hashUnordered :: [a] -&gt;
--   ([h], a -&gt; h)`) should be used to impose an order, and then apply
--   that order in further hashing. Otherwise the second argument (`hash ::
--   a -&gt; h`) should be used.
--   
--   Example 1: A simple functor with no unordered components. Hashable1
--   instance just uses <tt>hash</tt>:
--   
--   data T a = One a | Two a a deriving Functor
--   
--   instance Hashable1 T where hash1 _ hash t = case t of One a -&gt;
--   accumulate [Tag 0, Hashed (hash a)] Two a a2 -&gt; accumulate [Tag 1,
--   Hashed (hash a), Hashed (hash a2)]
--   
--   Example 2: A functor with unordered components. For hashing, we need
--   to pick a canonical ordering of the unordered components, so we use
--   <tt>hashUnordered</tt>:
--   
--   data U a = U { unordered :: [a], uno :: a, dos :: a } deriving Functor
--   
--   instance Hashable1 U where hash1 hashUnordered _ (U unordered uno dos)
--   = let (hs, hash) = hashUnordered unordered in accumulate $ map Hashed
--   hs ++ [Hashed (hash uno), Hashed (hash dos)]
hash1 :: (Hashable1 f, Ord h, Accumulate h) => ([a] -> ([h], a -> h)) -> (a -> h) -> f a -> h
instance Unison.Hashable.Hashable a => Unison.Hashable.Hashable [a]
instance (Unison.Hashable.Hashable a, Unison.Hashable.Hashable b) => Unison.Hashable.Hashable (a, b)
instance Unison.Hashable.Hashable a => Unison.Hashable.Hashable (Data.Set.Internal.Set a)
instance (Unison.Hashable.Hashable k, Unison.Hashable.Hashable v) => Unison.Hashable.Hashable (Data.Map.Internal.Map k v)
instance (Unison.Hashable.Hashable a, Unison.Hashable.Hashable b) => Unison.Hashable.Hashable (Unison.Util.Relation.Relation a b)
instance (Unison.Hashable.Hashable d1, Unison.Hashable.Hashable d2, Unison.Hashable.Hashable d3) => Unison.Hashable.Hashable (Unison.Util.Relation3.Relation3 d1 d2 d3)
instance (Unison.Hashable.Hashable d1, Unison.Hashable.Hashable d2, Unison.Hashable.Hashable d3, Unison.Hashable.Hashable d4) => Unison.Hashable.Hashable (Unison.Util.Relation4.Relation4 d1 d2 d3 d4)
instance Unison.Hashable.Hashable ()
instance Unison.Hashable.Hashable GHC.Types.Double
instance Unison.Hashable.Hashable Data.Text.Internal.Text
instance Unison.Hashable.Hashable GHC.Types.Char
instance Unison.Hashable.Hashable Data.ByteString.Internal.ByteString
instance Unison.Hashable.Hashable GHC.Word.Word64
instance Unison.Hashable.Hashable GHC.Int.Int64
instance Unison.Hashable.Hashable GHC.Types.Bool

module Unison.Hash

-- | Hash which uniquely identifies a Unison type or term
newtype Hash
Hash :: ShortByteString -> Hash
toBytes :: Hash -> ShortByteString

-- | Return the lowercase unpadded base32Hex encoding of this <a>Hash</a>.
--   Multibase prefix would be <tt>v</tt>, see
--   <a>https://github.com/multiformats/multibase</a>
base32Hex :: Hash -> Text
base32Hexs :: Hash -> String

-- | Produce a <a>Hash</a> from a base32hex-encoded version of its binary
--   representation
fromBase32Hex :: Text -> Maybe Hash
fromBytes :: ByteString -> Hash
fromByteString :: ByteString -> Hash
toByteString :: Hash -> ByteString
unsafeFromBase32Hex :: Text -> Hash
showBase32Hex :: Hashable t => t -> String
validBase32HexChars :: Set Char
instance GHC.Generics.Generic Unison.Hash.Hash
instance GHC.Classes.Ord Unison.Hash.Hash
instance GHC.Classes.Eq Unison.Hash.Hash
instance GHC.Show.Show Unison.Hash.Hash
instance Unison.Hashable.Hashable Unison.Hash.Hash
instance Unison.Hashable.Accumulate Unison.Hash.Hash

module Unison.ConstructorType
data ConstructorType
Data :: ConstructorType
Effect :: ConstructorType
instance GHC.Generics.Generic Unison.ConstructorType.ConstructorType
instance GHC.Enum.Enum Unison.ConstructorType.ConstructorType
instance GHC.Show.Show Unison.ConstructorType.ConstructorType
instance GHC.Classes.Ord Unison.ConstructorType.ConstructorType
instance GHC.Classes.Eq Unison.ConstructorType.ConstructorType
instance Unison.Hashable.Hashable Unison.ConstructorType.ConstructorType

module Unison.Kind
data Kind
Star :: Kind
Arrow :: Kind -> Kind -> Kind
instance GHC.Generics.Generic Unison.Kind.Kind
instance GHC.Show.Show Unison.Kind.Kind
instance GHC.Read.Read Unison.Kind.Kind
instance GHC.Classes.Ord Unison.Kind.Kind
instance GHC.Classes.Eq Unison.Kind.Kind
instance Unison.Hashable.Hashable Unison.Kind.Kind

module Unison.Referent'

-- | Specifies a term.
--   
--   Either a term <tt>Reference</tt>, a data constructor, or an effect
--   constructor.
--   
--   Slightly odd naming. This is the "referent of term name in the
--   codebase", rather than the target of a Reference.
--   
--   When <tt>Ref'</tt> then <tt>r</tt> represents a term.
--   
--   When <tt>Con'</tt> then <tt>r</tt> is a type declaration.
data Referent' r
Ref' :: r -> Referent' r
Con' :: r -> ConstructorId -> ConstructorType -> Referent' r
isConstructor :: Referent' r -> Bool
toTermReference :: Referent' r -> Maybe r
toReference' :: Referent' r -> r
toTypeReference :: Referent' r -> Maybe r
fold :: (r -> a) -> (r -> ConstructorId -> ConstructorType -> a) -> Referent' r -> a
instance GHC.Base.Functor Unison.Referent'.Referent'
instance GHC.Classes.Eq r => GHC.Classes.Eq (Unison.Referent'.Referent' r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (Unison.Referent'.Referent' r)
instance GHC.Show.Show r => GHC.Show.Show (Unison.Referent'.Referent' r)
instance Unison.Hashable.Hashable r => Unison.Hashable.Hashable (Unison.Referent'.Referent' r)

module Unison.Settings
debugNoteLoc :: Bool
debugNoteSummary :: Bool
debugRevealForalls :: Bool
renderTermMaxLength :: Int
demoHideVarNumber :: Bool
removePureEffects :: Bool
cleanupTypes :: Bool

module Unison.ShortHash
data ShortHash
Builtin :: Text -> ShortHash
ShortHash :: Text -> Maybe Text -> Maybe Text -> ShortHash
[prefix] :: ShortHash -> Text
[cycle] :: ShortHash -> Maybe Text
[cid] :: ShortHash -> Maybe Text
isConstructor :: ShortHash -> Bool
fromText :: Text -> Maybe ShortHash
unsafeFromText :: Text -> ShortHash
toText :: ShortHash -> Text
toString :: ShortHash -> String
fromString :: String -> Maybe ShortHash
take :: Int -> ShortHash -> ShortHash
isPrefixOf :: ShortHash -> ShortHash -> Bool
instance GHC.Generics.Generic Unison.ShortHash.ShortHash
instance GHC.Show.Show Unison.ShortHash.ShortHash
instance GHC.Classes.Ord Unison.ShortHash.ShortHash
instance GHC.Classes.Eq Unison.ShortHash.ShortHash

module Unison.Reference

-- | Either a builtin or a user defined (hashed) top-level declaration.
--   
--   Used for both terms and types. Doesn't distinguish between them.
--   
--   Other used defined things like local variables don't get
--   <tt>Reference</tt>s.
data Reference
pattern Builtin :: () => Text -> Reference
pattern Derived :: Hash -> Pos -> Size -> Reference
pattern DerivedId :: () => Id -> Reference

-- | <tt>Pos</tt> is a position into a cycle of size <tt>Size</tt>, as
--   cycles are hashed together.
data Id
Id :: Hash -> Pos -> Size -> Id
type Pos = Word64
type Size = Word64
derivedBase32Hex :: Text -> Pos -> Size -> Reference
data Component
members :: Component -> Set Reference
components :: [(Hash, [k])] -> [(k, Id)]
groupByComponent :: [(k, Reference)] -> [[(k, Reference)]]
componentFor :: Reference -> Component
unsafeFromText :: Text -> Reference
idFromText :: Text -> Maybe Id
isPrefixOf :: ShortHash -> Reference -> Bool
fromShortHash :: ShortHash -> Maybe Reference
fromText :: Text -> Either String Reference
readSuffix :: Text -> Either String (Pos, Size)
showShort :: Int -> Reference -> Text
showSuffix :: Pos -> Size -> Text
toId :: Reference -> Maybe Id
toText :: Reference -> Text
unsafeId :: Reference -> Id
toShortHash :: Reference -> ShortHash
idToShortHash :: Id -> ShortHash
instance GHC.Generics.Generic Unison.Reference.Id
instance GHC.Generics.Generic Unison.Reference.Reference
instance GHC.Classes.Ord Unison.Reference.Reference
instance GHC.Classes.Eq Unison.Reference.Reference
instance GHC.Show.Show Unison.Reference.Id
instance GHC.Show.Show Unison.Reference.Reference
instance Unison.Hashable.Hashable Unison.Reference.Reference
instance GHC.Classes.Eq Unison.Reference.Id
instance GHC.Classes.Ord Unison.Reference.Id

module Unison.Referent

-- | Specifies a term.
--   
--   Either a term <a>Reference</a>, a data constructor, or an effect
--   constructor.
--   
--   Slightly odd naming. This is the "referent of term name in the
--   codebase", rather than the target of a Reference.
type Referent = Referent' Reference
pattern Ref :: Reference -> Referent
pattern Con :: Reference -> ConstructorId -> ConstructorType -> Referent
type ConstructorId = Int

-- | By definition, cannot be a builtin.
type Id = Referent' Id
pattern RefId :: Id -> Id
pattern ConId :: Id -> ConstructorId -> ConstructorType -> Id
fold :: (r -> a) -> (r -> Int -> ConstructorType -> a) -> Referent' r -> a
toReference :: Referent -> Reference
fromText :: Text -> Maybe Referent
isPrefixOf :: ShortHash -> Referent -> Bool
toShortHash :: Referent -> ShortHash
toText :: Referent -> Text
toString :: Referent -> String
patternShortHash :: Reference -> Int -> ShortHash

module Unison.LabeledDependency
derivedTerm :: Id -> LabeledDependency
derivedType :: Id -> LabeledDependency
termRef :: Reference -> LabeledDependency
typeRef :: Reference -> LabeledDependency
referent :: Referent -> LabeledDependency
dataConstructor :: Reference -> ConstructorId -> LabeledDependency
effectConstructor :: Reference -> ConstructorId -> LabeledDependency
fold :: (Reference -> a) -> (Referent -> a) -> LabeledDependency -> a
referents :: Foldable f => f Referent -> Set LabeledDependency

-- | Left TypeRef | Right TermRef
toReference :: LabeledDependency -> Either Reference Reference
data LabeledDependency
partition :: Foldable t => t LabeledDependency -> ([Reference], [Referent])
instance GHC.Show.Show Unison.LabeledDependency.LabeledDependency
instance GHC.Classes.Ord Unison.LabeledDependency.LabeledDependency
instance GHC.Classes.Eq Unison.LabeledDependency.LabeledDependency

module Unison.Util.Alphabetical
class Eq n => Alphabetical n
compareAlphabetical :: Alphabetical n => n -> n -> Ordering
newtype OrderAlphabetically a
OrderAlphabetically :: a -> OrderAlphabetically a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.Alphabetical.OrderAlphabetically a)
instance Data.Foldable.Foldable Unison.Util.Alphabetical.OrderAlphabetically
instance Data.Traversable.Traversable Unison.Util.Alphabetical.OrderAlphabetically
instance GHC.Base.Functor Unison.Util.Alphabetical.OrderAlphabetically
instance (GHC.Classes.Eq a, Unison.Util.Alphabetical.Alphabetical a) => GHC.Classes.Ord (Unison.Util.Alphabetical.OrderAlphabetically a)
instance Unison.Util.Alphabetical.Alphabetical a => Unison.Util.Alphabetical.Alphabetical [a]
instance Unison.Util.Alphabetical.Alphabetical a => Unison.Util.Alphabetical.Alphabetical (GHC.Maybe.Maybe a)
instance Unison.Util.Alphabetical.Alphabetical Data.Text.Internal.Text

module Unison.NameSegment
newtype NameSegment
NameSegment :: Text -> NameSegment
[toText] :: NameSegment -> Text
segments' :: Text -> [Text]
reverseSegments' :: Text -> [Text]
isEmpty :: NameSegment -> Bool
isPrefixOf :: NameSegment -> NameSegment -> Bool
toString :: NameSegment -> String
instance GHC.Classes.Ord Unison.NameSegment.NameSegment
instance GHC.Classes.Eq Unison.NameSegment.NameSegment
instance Unison.Util.Alphabetical.Alphabetical Unison.NameSegment.NameSegment
instance Unison.Hashable.Hashable Unison.NameSegment.NameSegment
instance GHC.Show.Show Unison.NameSegment.NameSegment
instance Data.String.IsString Unison.NameSegment.NameSegment

module Unison.Util.Components

-- | Order bindings by dependencies and group into components. Each
--   component consists of &gt; 1 bindings, each of which depends
--   transitively on all other bindings in the component.
--   
--   1-element components may or may not depend on themselves.
--   
--   The order is such that a component at index i will not depend on
--   components and indexes &gt; i. But a component at index i does not
--   _necessarily_ depend on any components at earlier indices.
--   
--   Example:
--   
--   let rec ping n = pong (n + 1); pong n = ping (n + 1); g = id 42; y =
--   id "hi" id x = x; in ping g
--   
--   <a>components</a> would produce `[[ping,pong], [id], [g], [y]]` Notice
--   that <a>id</a> comes before <tt>g</tt> and <tt>y</tt> in the output,
--   since both <tt>g</tt> and <tt>y</tt> depend on <a>id</a>.
--   
--   Uses Tarjan's algorithm:
--   <a>https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</a>
components :: Ord v => (t -> Set v) -> [(v, t)] -> [[(v, t)]]

module Unison.ABT
data ABT f v r
Var :: v -> ABT f v r
Cycle :: r -> ABT f v r
Abs :: v -> r -> ABT f v r
Tm :: f r -> ABT f v r

-- | At each level in the tree, we store the set of free variables and a
--   value of type <tt>a</tt>. Variables are of type <tt>v</tt>.
data Term f v a
Term :: Set v -> a -> ABT f v (Term f v a) -> Term f v a
[freeVars] :: Term f v a -> Set v
[annotation] :: Term f v a -> a
[out] :: Term f v a -> ABT f v (Term f v a)

-- | A class for variables.
--   
--   <ul>
--   <li>`Set.notMember (freshIn vs v) vs`: <a>freshIn</a> returns a
--   variable not used in the <a>Set</a></li>
--   </ul>
class Ord v => Var v
freshIn :: Var v => Set v -> v -> v
data V v
Free :: v -> V v
Bound :: v -> V v
unvar :: V v -> v
newtype Path s t a b m
Path :: (s -> Maybe (a, b -> Maybe t, m)) -> Path s t a b m
[focus] :: Path s t a b m -> s -> Maybe (a, b -> Maybe t, m)
here :: Monoid m => Path s t s t m
type Path' f g m = forall a v. Var v => Path (Term f v a) (Term f (V v) a) (Term g v a) (Term g (V v) a) m
compose :: Monoid m => Path s t a b m -> Path a b a' b' m -> Path s t a' b' m
at :: Path s t a b m -> s -> Maybe a
modify' :: Path s t a b m -> (m -> a -> b) -> s -> Maybe t
wrap :: (Functor f, Foldable f, Var v) => v -> Term f (V v) a -> (V v, Term f (V v) a)
wrap' :: (Functor f, Foldable f, Var v) => v -> Term f (V v) a -> (V v -> Term f (V v) a -> c) -> c

-- | Return the list of all variables bound by this ABT
bound' :: Foldable f => Term f v a -> [v]
annotateBound' :: (Ord v, Functor f, Foldable f) => Term f v a0 -> Term f v [v]
annotateBound :: (Ord v, Foldable f, Functor f) => Term f v a -> Term f v (a, Set v)
annotateBound'' :: (Ord v, Functor f, Foldable f) => Term f v a -> Term f v (a, [v])

-- | Return the set of all variables bound by this ABT
bound :: (Ord v, Foldable f) => Term f v a -> Set v

-- | <a>True</a> if the term has no free variables, <a>False</a> otherwise
isClosed :: Term f v a -> Bool

-- | <a>True</a> if <tt>v</tt> is a member of the set of free variables of
--   <tt>t</tt>
isFreeIn :: Ord v => v -> Term f v a -> Bool

-- | Replace the annotation with the given argument.
annotate :: a -> Term f v a -> Term f v a
vmap :: (Functor f, Foldable f, Ord v2) => (v -> v2) -> Term f v a -> Term f v2 a
vmapM :: (Applicative m, Traversable f, Foldable f, Ord v2) => (v -> m v2) -> Term f v a -> m (Term f v2 a)
amap :: (Functor f, Foldable f, Ord v) => (a -> a2) -> Term f v a -> Term f v a2
amap' :: (Functor f, Foldable f, Ord v) => (Term f v a -> a -> a2) -> Term f v a -> Term f v a2
extraMap :: Functor g => (forall k. f k -> g k) -> Term f v a -> Term g v a
pattern Var' :: forall f v a. v -> Term f v a
pattern Cycle' :: forall f v a. [v] -> Term f v a -> Term f v a
pattern Abs' :: (Foldable f, Functor f, Var v) => Subst f v a -> Term f v a
pattern AbsN' :: forall f v a. [v] -> Term f v a -> Term f v a
pattern Tm' :: f (Term f v a) -> Term f v a
pattern CycleA' :: forall f v a. a -> [(a, v)] -> Term f v a -> Term f v a
pattern AbsNA' :: forall f v a. [(a, v)] -> Term f v a -> Term f v a
pattern Abs1NA' :: forall f v a. [(a, v)] -> Term f v a -> Term f v a
unabsA :: Term f v a -> ([(a, v)], Term f v a)
unabs1A :: Term f v a -> Maybe ([(a, v)], Term f v a)
var :: v -> Term f v ()
annotatedVar :: a -> v -> Term f v a
abs :: Ord v => v -> Term f v () -> Term f v ()
abs' :: Ord v => a -> v -> Term f v a -> Term f v a
absr :: (Functor f, Foldable f, Var v) => v -> Term f (V v) () -> Term f (V v) ()

-- | Rebuild an <a>abs</a>, renaming <tt>v</tt> to avoid capturing any
--   `Free v` in <tt>body</tt>.
absr' :: (Functor f, Foldable f, Var v) => a -> v -> Term f (V v) a -> Term f (V v) a
absChain :: Ord v => [v] -> Term f v () -> Term f v ()
absCycle :: Ord v => [v] -> Term f v () -> Term f v ()
absChain' :: Ord v => [(a, v)] -> Term f v a -> Term f v a
tm :: (Foldable f, Ord v) => f (Term f v ()) -> Term f v ()
tm' :: (Foldable f, Ord v) => a -> f (Term f v a) -> Term f v a
cycle :: Term f v () -> Term f v ()
cycle' :: a -> Term f v a -> Term f v a
cycler' :: (Functor f, Foldable f, Var v) => a -> [v] -> Term f (V v) a -> Term f (V v) a
cycler :: (Functor f, Foldable f, Var v) => [v] -> Term f (V v) () -> Term f (V v) ()
into :: (Foldable f, Ord v) => ABT f v (Term f v ()) -> Term f v ()
into' :: (Foldable f, Ord v) => a -> ABT f v (Term f v a) -> Term f v a

-- | renames <tt>old</tt> to <tt>new</tt> in the given term, ignoring
--   subtrees that bind <tt>old</tt>
rename :: (Foldable f, Functor f, Var v) => v -> v -> Term f v a -> Term f v a
renames :: (Foldable f, Functor f, Var v) => Map v v -> Term f v a -> Term f v a
changeVars :: (Foldable f, Functor f, Var v) => Map v v -> Term f v a -> Term f v a

-- | Produce a variable which is free in both terms
freshInBoth :: Var v => Term f v a -> Term f v a -> v -> v
fresh :: Var v => Term f v a -> v -> v
freshEverywhere :: (Foldable f, Var v) => Term f v a -> v -> v
allVars :: Foldable f => Term f v a -> [v]
freshes :: Var v => Term f v a -> [v] -> [v]
freshes' :: Var v => Set v -> [v] -> [v]

-- | Freshens the given variable wrt. the set of used variables tracked by
--   state. Adds the result to the set of used variables.
freshenS :: (Var v, MonadState (Set v) m) => v -> m v

-- | A more general version of <a>freshenS</a> that uses a lens to focus on
--   used variables inside state.
freshenS' :: (Var v, MonadState s m) => Lens' s (Set v) -> v -> m v

-- | `subst v e body` substitutes <tt>e</tt> for <tt>v</tt> in
--   <tt>body</tt>, avoiding capture by renaming abstractions in
--   <tt>body</tt>
subst :: (Foldable f, Functor f, Var v) => v -> Term f v a -> Term f v a -> Term f v a
subst' :: (Foldable f, Functor f, Var v) => (a -> Term f v a) -> v -> Set v -> Term f v a -> Term f v a
substInheritAnnotation :: (Foldable f, Functor f, Var v) => v -> Term f v b -> Term f v a -> Term f v a
substsInheritAnnotation :: (Foldable f, Functor f, Var v) => [(v, Term f v b)] -> Term f v a -> Term f v a

-- | `substs [(t1,v1), (t2,v2), ...] body` performs multiple simultaneous
--   substitutions, avoiding capture
substs :: (Foldable f, Functor f, Var v) => [(v, Term f v a)] -> Term f v a -> Term f v a
occurrences :: (Foldable f, Var v) => v -> Term f v a -> Int
rebuildUp :: (Ord v, Foldable f, Functor f) => (f (Term f v a) -> f (Term f v a)) -> Term f v a -> Term f v a
rebuildUp' :: (Ord v, Foldable f, Functor f) => (Term f v a -> Term f v a) -> Term f v a -> Term f v a
freeVarOccurrences :: (Traversable f, Ord v) => Set v -> Term f v a -> [(v, a)]
foreachSubterm :: (Traversable f, Applicative g, Ord v) => (Term f v a -> g b) -> Term f v a -> g [b]
subterms :: (Ord v, Traversable f) => Term f v a -> [Term f v a]

-- | `visit f t` applies an effectful function to each subtree of
--   <tt>t</tt> and sequences the results. When <tt>f</tt> returns
--   <a>Nothing</a>, <a>visit</a> descends into the children of the current
--   subtree. When <tt>f</tt> returns `Just t2`, <a>visit</a> replaces the
--   current subtree with <tt>t2</tt>. Thus: `visit (const Nothing) t ==
--   pure t` and `visit (const (Just (pure t2))) t == pure t2`
visit :: (Traversable f, Applicative g, Ord v) => (Term f v a -> Maybe (g (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit' :: (Traversable f, Applicative g, Monad g, Ord v) => (f (Term f v a) -> g (f (Term f v a))) -> Term f v a -> g (Term f v a)

-- | <a>visit</a> specialized to the <tt>Identity</tt> effect.
visitPure :: (Traversable f, Ord v) => (Term f v a -> Maybe (Term f v a)) -> Term f v a -> Term f v a
rewriteDown :: (Traversable f, Ord v) => (Term f v a -> Term f v a) -> Term f v a -> Term f v a
data Subst f v a
Subst :: (forall m v'. Monad m => (v -> m v') -> m v') -> (Term f v a -> Term f v a) -> (forall b. Term f v b -> Term f v a) -> v -> Subst f v a
[freshen] :: Subst f v a -> forall m v'. Monad m => (v -> m v') -> m v'
[bind] :: Subst f v a -> Term f v a -> Term f v a
[bindInheritAnnotation] :: Subst f v a -> forall b. Term f v b -> Term f v a
[variable] :: Subst f v a -> v
unabs1 :: (Foldable f, Functor f, Var v) => Term f v a -> Maybe (Subst f v a)
unabs :: Term f v a -> ([v], Term f v a)
reabs :: Ord v => [v] -> Term f v () -> Term f v ()
transform :: (Ord v, Foldable g, Functor f) => (forall a. f a -> g a) -> Term f v a -> Term g v a
transformM :: (Ord v, Monad m, Traversable g) => (forall a. f a -> m (g a)) -> Term f v a -> m (Term g v a)
reannotateUp :: (Ord v, Foldable f, Functor f, Monoid b) => (Term f v a -> b) -> Term f v a -> Term f v (a, b)
data FindAction x
Found :: x -> FindAction x
Prune :: FindAction x
Continue :: FindAction x
find :: (Ord v, Foldable f, Functor f) => (Term f v a -> FindAction x) -> Term f v a -> [x]
find' :: (Ord v, Foldable f, Functor f) => (Term f v a -> Bool) -> Term f v a -> [Term f v a]
components :: Var v => [(v, Term f v a)] -> [[(v, Term f v a)]]
orderedComponents' :: Var v => [(v, Term f v a)] -> [[(v, Term f v a)]]
orderedComponents :: Var v => [(v, Term f v a)] -> [[(v, Term f v a)]]
hashComponent :: (Functor f, Hashable1 f, Foldable f, Eq v, Show v, Ord v, Ord h, Accumulate h) => Map v (Term f v a) -> (h, [(v, Term f v a)])
hashComponents :: (Functor f, Hashable1 f, Foldable f, Eq v, Show v, Var v, Ord h, Accumulate h) => (h -> Word64 -> Word64 -> Term f v ()) -> Map v (Term f v a) -> [(h, [(v, Term f v a)])]
data Component f a
Component :: [a] -> a -> Component f a
Embed :: f a -> Component f a

-- | We ignore annotations in the <a>Term</a>, as these should never affect
--   the meaning of the term.
hash :: forall f v a h. (Functor f, Hashable1 f, Eq v, Show v, Ord h, Accumulate h) => Term f v a -> h

-- | Use the <a>hash</a> function to efficiently remove duplicates from the
--   list, preserving order.
distinct :: forall f v h a proxy. (Functor f, Hashable1 f, Eq v, Show v, Ord h, Accumulate h) => proxy h -> [Term f v a] -> [Term f v a]

-- | Use the <a>hash</a> function to remove elements from <tt>t1s</tt> that
--   exist in <tt>t2s</tt>, preserving order.
subtract :: forall f v h a proxy. (Functor f, Hashable1 f, Eq v, Show v, Ord h, Accumulate h) => proxy h -> [Term f v a] -> [Term f v a] -> [Term f v a]
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Unison.ABT.ABT f v)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Unison.ABT.ABT f v)
instance GHC.Base.Functor f => GHC.Base.Functor (Unison.ABT.ABT f v)
instance GHC.Base.Functor Unison.ABT.V
instance GHC.Show.Show v => GHC.Show.Show (Unison.ABT.V v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.ABT.V v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.ABT.V v)
instance GHC.Show.Show x => GHC.Show.Show (Unison.ABT.FindAction x)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Unison.ABT.Component f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Unison.ABT.Component f)
instance GHC.Base.Functor f => GHC.Base.Functor (Unison.ABT.Component f)
instance (Unison.Hashable.Hashable1 f, GHC.Base.Functor f) => Unison.Hashable.Hashable1 (Unison.ABT.Component f)
instance GHC.Base.Semigroup (Unison.ABT.Path s t a b m)
instance GHC.Base.Monoid (Unison.ABT.Path s t a b m)
instance Unison.ABT.Var v => Unison.ABT.Var (Unison.ABT.V v)
instance (Data.Foldable.Foldable f, GHC.Base.Functor f, Prelude.Extras.Eq1 f, Unison.ABT.Var v) => GHC.Classes.Eq (Unison.ABT.Term f v a)
instance (Data.Foldable.Foldable f, GHC.Base.Functor f, Prelude.Extras.Ord1 f, Unison.ABT.Var v) => GHC.Classes.Ord (Unison.ABT.Term f v a)
instance GHC.Base.Functor f => GHC.Base.Functor (Unison.ABT.Term f v)
instance (Prelude.Extras.Show1 f, GHC.Show.Show v) => GHC.Show.Show (Unison.ABT.Term f v a)

module Unison.Reference.Util
hashComponents :: (Functor f, Hashable1 f, Foldable f, Eq v, Show v, Var v) => (Id -> Term f v ()) -> Map v (Term f v a) -> Map v (Id, Term f v a)

module Unison.ABT.Normalized
data ABT f v
Abs :: v -> Term f v -> ABT f v
Tm :: f v (Term f v) -> ABT f v
data Term f v
Term :: Set v -> ABT f v -> Term f v
[freeVars] :: Term f v -> Set v
[out] :: Term f v -> ABT f v
pattern TAbs :: Var v => v -> Term f v -> Term f v
pattern TTm :: (Var v, Bifoldable f) => f v (Term f v) -> Term f v
pattern TAbss :: Var v => [v] -> Term f v -> Term f v
renames :: (Var v, Ord v, Bifunctor f, Bifoldable f) => Map v Int -> Map v v -> Term f v -> Term f v
rename :: (Var v, Ord v, Bifunctor f, Bifoldable f) => v -> v -> Term f v -> Term f v
transform :: (Var v, Bifunctor g, Bifoldable f, Bifoldable g) => (forall a b. f a b -> g a b) -> Term f v -> Term g v
instance (forall a b. (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (f a b), GHC.Show.Show v) => GHC.Show.Show (Unison.ABT.Normalized.ABT f v)
instance (forall a b. (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (f a b), GHC.Show.Show v) => GHC.Show.Show (Unison.ABT.Normalized.Term f v)

module Unison.Util.List
multimap :: Foldable f => Ord k => f (k, v) -> Map k [v]
groupBy :: (Foldable f, Ord k) => (v -> k) -> f v -> Map k [v]
uniqueBy :: (Foldable f, Ord b) => (a -> b) -> f a -> [a]
nubOrdOn :: (Foldable f, Ord b) => (a -> b) -> f a -> [a]
uniqueBy' :: (Foldable f, Ord b) => (a -> b) -> f a -> [a]
safeHead :: Foldable f => f a -> Maybe a
validate :: (Semigroup e, Foldable f) => (a -> Either e b) -> f a -> Either e [b]
intercalateMapWith :: (a -> a -> b) -> (a -> b) -> [a] -> [b]
quenchRuns :: Eq a => a -> a -> [a] -> [a]

module Unison.Util.Monoid
intercalateMap :: (Foldable t, Monoid a) => a -> (b -> a) -> t b -> a
fromMaybe :: Monoid a => Maybe a -> a
whenM :: Monoid a => Bool -> a -> a
unlessM :: Monoid a => Bool -> a -> a
isEmpty :: (Eq a, Monoid a) => a -> Bool
nonEmpty :: (Eq a, Monoid a) => a -> Bool
foldMapM :: (Monad m, Foldable f, Monoid b) => (a -> m b) -> f a -> m b

module Unison.Util.Set
symmetricDifference :: Ord a => Set a -> Set a -> Set a
mapMaybe :: (Ord a, Ord b) => (a -> Maybe b) -> Set a -> Set b

module Unison.WatchKind
type WatchKind = String
pattern RegularWatch :: (Eq a, IsString a) => a
pattern TestWatch :: (Eq a, IsString a) => a

module Unison.Var

-- | A class for variables. Variables may have auxiliary information which
--   may not form part of their identity according to <a>Eq</a> /
--   <a>Ord</a>. Laws:
--   
--   <ul>
--   <li>`typeOf (typed n) == n`</li>
--   <li>`typeOf (ABT.freshIn vs v) == typeOf v`: <a>freshIn</a> does not
--   alter the name</li>
--   </ul>
class (Show v, Var v) => Var v
typed :: Var v => Type -> v
typeOf :: Var v => v -> Type
freshId :: Var v => v -> Word64
freshenId :: Var v => Word64 -> v -> v
freshIn :: Var v => Set v -> v -> v
named :: Var v => Text -> v
rawName :: Type -> Text
name :: Var v => v -> Text
uncapitalize :: Var v => v -> v
missingResult :: Var v => v
blank :: Var v => v
inferInput :: Var v => v
inferOutput :: Var v => v
inferAbility :: Var v => v
inferPatternPureE :: Var v => v
inferPatternPureV :: Var v => v
inferPatternBindE :: Var v => v
inferPatternBindV :: Var v => v
inferTypeConstructor :: Var v => v
inferTypeConstructorArg :: Var v => v
inferOther :: Var v => v
unnamedTest :: Var v => Text -> v
data Type
User :: Text -> Type
Inference :: InferenceType -> Type
MissingResult :: Type
Blank :: Type
UnnamedWatch :: WatchKind -> Text -> Type
Eta :: Type
ANFBlank :: Type
Float :: Type
Pattern :: Type
Irrelevant :: Type
data InferenceType
Ability :: InferenceType
Input :: InferenceType
Output :: InferenceType
PatternPureE :: InferenceType
PatternPureV :: InferenceType
PatternBindE :: InferenceType
PatternBindV :: InferenceType
TypeConstructor :: InferenceType
TypeConstructorArg :: InferenceType
Other :: InferenceType
reset :: Var v => v -> v
unqualifiedName :: Var v => v -> Text
unqualified :: Var v => v -> v
namespaced :: Var v => [v] -> v
nameStr :: Var v => v -> String
nameds :: Var v => String -> v
joinDot :: Var v => v -> v -> v
freshNamed :: Var v => Set v -> Text -> v
universallyQuantifyIfFree :: forall v. Var v => v -> Bool
instance GHC.Show.Show Unison.Var.InferenceType
instance GHC.Classes.Ord Unison.Var.InferenceType
instance GHC.Classes.Eq Unison.Var.InferenceType
instance GHC.Show.Show Unison.Var.Type
instance GHC.Classes.Ord Unison.Var.Type
instance GHC.Classes.Eq Unison.Var.Type

module Unison.Var.RefNamed
refNamed :: Var v => Reference -> v

module Unison.Symbol
data Symbol
Symbol :: !Word64 -> Type -> Symbol
symbol :: Text -> Symbol
instance GHC.Generics.Generic Unison.Symbol.Symbol
instance Unison.ABT.Var Unison.Symbol.Symbol
instance Unison.Var.Var Unison.Symbol.Symbol
instance GHC.Classes.Eq Unison.Symbol.Symbol
instance GHC.Classes.Ord Unison.Symbol.Symbol
instance GHC.Show.Show Unison.Symbol.Symbol

module Unison.Name
newtype Name
Name :: Text -> Name
class Convert a b
convert :: Convert a b => a -> b
class Parse a b
parse :: Parse a b => a -> Maybe b
endsWithSegments :: Name -> Name -> Bool
fromString :: IsString a => String -> a
isPrefixOf :: Name -> Name -> Bool
joinDot :: Name -> Name -> Name
makeAbsolute :: Name -> Name
isAbsolute :: Name -> Bool
parent :: Name -> Maybe Name
class Eq n => Alphabetical n
compareAlphabetical :: Alphabetical n => n -> n -> Ordering
sortNames :: [Name] -> [Name]
sortNamed :: (a -> Name) -> [a] -> [a]
sortNameds :: (a -> [Name]) -> [a] -> [a]
sortByText :: (a -> Text) -> [a] -> [a]

-- | Like sortNamed, but takes an additional backup comparison function if
--   two names are equal.
sortNamed' :: (a -> Name) -> (a -> a -> Ordering) -> [a] -> [a]
stripNamePrefix :: Name -> Name -> Maybe Name
stripPrefixes :: Name -> Name
segments :: Name -> [NameSegment]
reverseSegments :: Name -> [NameSegment]
countSegments :: Name -> Int
compareSuffix :: Name -> Name -> Ordering
segments' :: Text -> [Text]
suffixes :: Name -> [Name]
searchBySuffix :: Ord r => Name -> Relation Name r -> Set r
suffixFrom :: Name -> Name -> Maybe Name
shortestUniqueSuffix :: Ord r => Name -> r -> Relation Name r -> Name
toString :: Name -> String
toText :: Name -> Text
toVar :: Var v => Name -> v
unqualified :: Name -> Name
unqualified' :: Text -> Text
unsafeFromText :: Text -> Name
unsafeFromString :: String -> Name
fromSegment :: NameSegment -> Name
fromVar :: Var v => v -> Name
instance GHC.Generics.Generic Unison.Name.Name
instance GHC.Classes.Eq Unison.Name.Name
instance Unison.Name.Parse Data.Text.Internal.Text Unison.NameSegment.NameSegment
instance (Unison.Name.Parse a a2, Unison.Name.Parse b b2) => Unison.Name.Parse (a, b) (a2, b2)
instance Unison.Name.Convert Unison.Name.Name Data.Text.Internal.Text
instance Unison.Name.Convert Unison.Name.Name [Unison.NameSegment.NameSegment]
instance Unison.Name.Convert Unison.NameSegment.NameSegment Unison.Name.Name
instance Unison.Name.Convert [Unison.NameSegment.NameSegment] Unison.Name.Name
instance GHC.Show.Show Unison.Name.Name
instance Data.String.IsString Unison.Name.Name
instance Unison.Hashable.Hashable Unison.Name.Name
instance GHC.Classes.Ord Unison.Name.Name
instance Unison.Util.Alphabetical.Alphabetical Unison.Name.Name
instance Control.Lens.Cons.Snoc Unison.Name.Name Unison.Name.Name Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment

module Unison.HashQualified
data HashQualified n
NameOnly :: n -> HashQualified n
HashOnly :: ShortHash -> HashQualified n
HashQualified :: n -> ShortHash -> HashQualified n
stripNamespace :: Text -> HashQualified Name -> HashQualified Name
toName :: HashQualified n -> Maybe n
sortByLength :: [HashQualified Name] -> [HashQualified Name]
hasName :: HashQualified Name -> Bool
hasHash :: HashQualified Name -> Bool
toHash :: HashQualified n -> Maybe ShortHash
fromNameHash :: Maybe Name -> Maybe ShortHash -> HashQualified Name
take :: Int -> HashQualified n -> HashQualified n
toString :: Show n => HashQualified n -> String
fromString :: String -> Maybe (HashQualified Name)
unsafeFromString :: String -> HashQualified Name
fromText :: Text -> Maybe (HashQualified Name)
unsafeFromText :: Text -> HashQualified Name
toText :: Show n => HashQualified n -> Text
fromNamedReferent :: n -> Referent -> HashQualified n
fromNamedReference :: n -> Reference -> HashQualified n
fromReferent :: Referent -> HashQualified Name
fromReference :: Reference -> HashQualified Name
fromPattern :: Reference -> ConstructorId -> HashQualified Name
fromName :: n -> HashQualified n
unsafeFromVar :: Var v => v -> HashQualified Name
fromVar :: Var v => v -> Maybe (HashQualified Name)
toVar :: Var v => HashQualified Name -> v
matchesNamedReferent :: Name -> Referent -> HashQualified Name -> Bool
matchesNamedReference :: Name -> Reference -> HashQualified Name -> Bool
requalify :: HashQualified Name -> Referent -> HashQualified Name
instance GHC.Generics.Generic (Unison.HashQualified.HashQualified n)
instance GHC.Show.Show n => GHC.Show.Show (Unison.HashQualified.HashQualified n)
instance GHC.Base.Functor Unison.HashQualified.HashQualified
instance Data.Traversable.Traversable Unison.HashQualified.HashQualified
instance Data.Foldable.Foldable Unison.HashQualified.HashQualified
instance GHC.Classes.Eq n => GHC.Classes.Eq (Unison.HashQualified.HashQualified n)
instance (GHC.Classes.Eq n, Unison.Util.Alphabetical.Alphabetical n) => GHC.Classes.Ord (Unison.HashQualified.HashQualified n)
instance Unison.Name.Convert n n2 => Unison.Name.Convert (Unison.HashQualified.HashQualified n) (Unison.HashQualified.HashQualified n2)
instance Unison.Name.Convert n (Unison.HashQualified.HashQualified n)
instance Unison.Name.Parse Data.Text.Internal.Text (Unison.HashQualified.HashQualified Unison.Name.Name)

module Unison.HashQualified'
data HashQualified n
NameOnly :: n -> HashQualified n
HashQualified :: n -> ShortHash -> HashQualified n
type HQSegment = HashQualified NameSegment
toHQ :: HashQualified n -> HashQualified n
fromHQ :: HashQualified n -> Maybe (HashQualified n)

-- | Like <a>fromHQ</a>, but if the <a>HashQualified</a> is just a
--   <a>ShortHash</a>, return it on the <a>Left</a>, rather than as a
--   <a>Nothing</a>.
fromHQ2 :: HashQualified n -> Either ShortHash (HashQualified n)
toName :: HashQualified n -> n
nameLength :: HashQualified Name -> Int
take :: Int -> HashQualified n -> HashQualified n
toNameOnly :: HashQualified n -> HashQualified n
toHash :: HashQualified n -> Maybe ShortHash
toString :: Show n => HashQualified n -> String
fromText :: Text -> Maybe (HashQualified Name)
unsafeFromText :: Text -> HashQualified Name
fromString :: String -> Maybe (HashQualified Name)
toText :: Show n => HashQualified n -> Text
fromNamedReferent :: n -> Referent -> HashQualified n
fromNamedReference :: n -> Reference -> HashQualified n
fromName :: n -> HashQualified n
matchesNamedReferent :: Eq n => n -> Referent -> HashQualified n -> Bool
matchesNamedReference :: Eq n => n -> Reference -> HashQualified n -> Bool
requalify :: HashQualified Name -> Referent -> HashQualified Name
instance Data.Foldable.Foldable Unison.HashQualified'.HashQualified
instance GHC.Generics.Generic (Unison.HashQualified'.HashQualified n)
instance GHC.Base.Functor Unison.HashQualified'.HashQualified
instance GHC.Classes.Eq n => GHC.Classes.Eq (Unison.HashQualified'.HashQualified n)
instance Unison.Util.Alphabetical.Alphabetical n => GHC.Classes.Ord (Unison.HashQualified'.HashQualified n)
instance Data.String.IsString (Unison.HashQualified'.HashQualified Unison.Name.Name)
instance GHC.Show.Show n => GHC.Show.Show (Unison.HashQualified'.HashQualified n)
instance Unison.Name.Convert n n2 => Unison.Name.Parse (Unison.HashQualified'.HashQualified n) n2
instance Unison.Name.Convert (Unison.HashQualified'.HashQualified n) (Unison.HashQualified.HashQualified n)
instance Unison.Name.Parse (Unison.HashQualified.HashQualified n) (Unison.HashQualified'.HashQualified n)
instance Unison.Name.Parse Data.Text.Internal.Text (Unison.HashQualified'.HashQualified Unison.Name.Name)

module Unison.Names
data Names
Names :: Relation Name Referent -> Relation Name Reference -> Names
[terms] :: Names -> Relation Name Referent
[types] :: Names -> Relation Name Reference
addTerm :: Name -> Referent -> Names -> Names
addType :: Name -> Reference -> Names -> Names
allReferences :: Names -> Set Reference

-- | filters out everything from the domain except what's conflicted
conflicts :: Names -> Names
contains :: Names -> Reference -> Bool
difference :: Names -> Names -> Names
filter :: (Name -> Bool) -> Names -> Names
filterByHQs :: Set (HashQualified Name) -> Names -> Names
filterBySHs :: Set ShortHash -> Names -> Names
filterTypes :: (Name -> Bool) -> Names -> Names
map :: (Name -> Name) -> Names -> Names
makeAbsolute :: Names -> Names
fuzzyFind :: [String] -> Names -> [(Alignment, Name, Set (Either Referent Reference))]

-- | Like hqTermName and hqTypeName, but considers term and type names to
--   conflict with each other (so will hash-qualify if there is e.g. both a
--   term and a type named "foo").
--   
--   This is useful in contexts such as printing branch diffs. Example:
--   
--   <ul>
--   <li>Deletes:</li>
--   </ul>
--   
--   foo foo
--   
--   We want to append the hash regardless of whether or not one is a term
--   and the other is a type.
hqName :: Names -> Name -> Either Reference Referent -> HashQualified Name
hqTermName :: Int -> Names -> Name -> Referent -> HashQualified Name
hqTypeName :: Int -> Names -> Name -> Reference -> HashQualified Name
hqTermName' :: Int -> Name -> Referent -> HashQualified Name
hqTypeName' :: Int -> Name -> Reference -> HashQualified Name
_hqTermName :: Names -> Name -> Referent -> HashQualified Name
_hqTypeName :: Names -> Name -> Reference -> HashQualified Name
_hqTermAliases :: Names -> Name -> Referent -> Set (HashQualified Name)
_hqTypeAliases :: Names -> Name -> Reference -> Set (HashQualified Name)
prefix0 :: Name -> Names -> Names
restrictReferences :: Set Reference -> Names -> Names
refTermsNamed :: Names -> Name -> Set Reference
termReferences :: Names -> Set Reference
termReferents :: Names -> Set Referent
typeReferences :: Names -> Set Reference
termsNamed :: Names -> Name -> Set Referent
typesNamed :: Names -> Name -> Set Reference
unionLeft :: Names -> Names -> Names

-- | Guide to unionLeft* Is it ok to create new aliases for parsing? Sure.
--   
--   Is it ok to create name conflicts for parsing? It's okay but not
--   great. The user will have to hash-qualify to disambiguate.
--   
--   Is it ok to create new aliases for pretty-printing? Not helpful, we
--   need to choose a name to show. We'll just have to choose one at random
--   if there are aliases. Is it ok to create name conflicts for
--   pretty-printing? Still okay but not great. The pretty-printer will
--   have to hash-qualify to disambiguate.
--   
--   Thus, for parsing: unionLeftName is good if the name <tt>n</tt> on the
--   left is the only <tt>n</tt> the user will want to reference. It allows
--   the rhs to add aliases. unionLeftRef allows new conflicts but no new
--   aliases. Lame? (&lt;&gt;) is ok for parsing if we expect to add some
--   conflicted names, e.g. from history
--   
--   For pretty-printing: Probably don't want to add new aliases, unless we
--   don't know which <a>Names</a> is higher priority. So if we do have a
--   preferred <a>Names</a>, don't use <a>unionLeftName</a> or (&lt;&gt;).
--   You don't want to create new conflicts either if you have a preferred
--   <a>Names</a>. So in this case, don't use <tt>unionLeftRef</tt> either.
--   I guess that leaves <a>unionLeft</a>.
--   
--   Not sure if the above is helpful or correct!
unionLeftName :: Names -> Names -> Names
namesForReference :: Names -> Reference -> Set Name
namesForReferent :: Names -> Referent -> Set Name
shadowTerms :: [Name] -> Names -> Names

-- | Given a mapping from name to qualified name, update a <a>Names</a>, so
--   for instance if the input has [(Some, Optional.Some)], and <a>Some</a>
--   is a constructor in the input <a>Names</a>, the alias <tt>Some</tt>
--   will map to that same constructor and shadow anything else that is
--   currently called <tt>Some</tt>.
importing :: [(Name, Name)] -> Names -> Names
constructorsForType :: Reference -> Names -> [(Name, Referent)]

-- | Converts a wildcard import into a list of explicit imports, of the
--   form [(suffix, full)]. Example: if <tt>io</tt> contains two functions,
--   <tt>foo</tt> and <tt>bar</tt>, then `expandWildcardImport io` will
--   produce `[(foo, io.foo), (bar, io.bar)]`.
expandWildcardImport :: Name -> Names -> [(Name, Name)]
isEmpty :: Names -> Bool
hashQualifyTypesRelation :: Relation Name Reference -> Relation (HashQualified Name) Reference
hashQualifyTermsRelation :: Relation Name Referent -> Relation (HashQualified Name) Referent
instance GHC.Classes.Ord Unison.Names.Names
instance GHC.Classes.Eq Unison.Names.Names
instance GHC.Base.Semigroup Unison.Names.Names
instance GHC.Base.Monoid Unison.Names.Names
instance GHC.Show.Show Unison.Names.Names

module Unison.NamesWithHistory

-- | NamesWithHistory contains two sets of <a>Names</a>, One represents
--   names which are currently assigned, the other represents names which
--   no longer apply, perhaps they've been deleted, or the term was updated
--   and the name points elsewhere now.
data NamesWithHistory
NamesWithHistory :: Names -> Names -> NamesWithHistory

-- | currentNames represent references which are named in the current
--   version of the namespace.
[currentNames] :: NamesWithHistory -> Names

-- | oldNames represent things which no longer have names in the current
--   version of the codebase, but which may have previously had names. This
--   may allow us to show more helpful context to users rather than just a
--   hash.
[oldNames] :: NamesWithHistory -> Names
filterTypes :: (Name -> Bool) -> Names -> Names
diff :: Names -> Names -> Diff
data Diff
Diff :: Names -> Names -> Names -> Diff
[originalNames] :: Diff -> Names
[addedNames] :: Diff -> Names
[removedNames] :: Diff -> Names
push :: Names -> NamesWithHistory -> NamesWithHistory
shadowing :: Names -> NamesWithHistory -> NamesWithHistory
lookupRelativeHQType :: HashQualified Name -> NamesWithHistory -> Set Reference
lookupRelativeHQType' :: HashQualified Name -> NamesWithHistory -> Set Reference

-- | Find all types whose name has a suffix matching the provided
--   <a>HashQualified</a>.
lookupHQType :: HashQualified Name -> NamesWithHistory -> Set Reference

-- | Find all types whose name has a suffix matching the provided
--   <tt>HashQualified'</tt>. See <a>lookupHQType</a>.
lookupHQType' :: HashQualified Name -> NamesWithHistory -> Set Reference
hasTermNamed :: Name -> NamesWithHistory -> Bool
hasTypeNamed :: Name -> NamesWithHistory -> Bool
lookupRelativeHQTerm :: HashQualified Name -> NamesWithHistory -> Set Referent
lookupRelativeHQTerm' :: HashQualified Name -> NamesWithHistory -> Set Referent

-- | Find all terms whose name has a suffix matching the provided
--   <a>HashQualified</a>.
--   
--   If the hash-qualified name does not include a hash, then only current
--   names are searched. Otherwise, old names are searched, too, if
--   searching current names produces no hits.
lookupHQTerm :: HashQualified Name -> NamesWithHistory -> Set Referent

-- | Find all terms whose name has a suffix matching the provided
--   <tt>HashQualified'</tt>. See <a>lookupHQTerm</a>.
lookupHQTerm' :: HashQualified Name -> NamesWithHistory -> Set Referent
lookupHQRef :: forall r. Ord r => (Names -> Relation Name r) -> (ShortHash -> r -> Bool) -> HashQualified Name -> NamesWithHistory -> Set r
typeName :: Int -> Reference -> NamesWithHistory -> Set (HashQualified Name)
termNamesByLength :: Int -> Referent -> NamesWithHistory -> [HashQualified Name]
longestTermName :: Int -> Referent -> NamesWithHistory -> HashQualified Name
termName :: Int -> Referent -> NamesWithHistory -> Set (HashQualified Name)
suffixedTypeName :: Int -> Reference -> NamesWithHistory -> [HashQualified Name]
suffixedTermName :: Int -> Referent -> NamesWithHistory -> [HashQualified Name]
lookupHQPattern :: HashQualified Name -> ConstructorType -> NamesWithHistory -> Set (Reference, Int)

-- | Given a mapping from name to qualified name, update a <a>Names</a>, so
--   for instance if the input has [(Some, Optional.Some)], and <a>Some</a>
--   is a constructor in the input <a>Names</a>, the alias <tt>Some</tt>
--   will map to that same constructor and shadow anything else that is
--   currently called <tt>Some</tt>.
--   
--   Only affects <a>currentNames</a>.
importing :: [(Name, Name)] -> NamesWithHistory -> NamesWithHistory
instance GHC.Show.Show Unison.NamesWithHistory.NamesWithHistory
instance GHC.Show.Show Unison.NamesWithHistory.Diff

module Unison.Names.ResolutionResult
data ResolutionError ref
NotFound :: ResolutionError ref
Ambiguous :: Names -> NESet ref -> ResolutionError ref

-- | ResolutionFailure represents the failure to resolve a given variable.
data ResolutionFailure var annotation
TypeResolutionFailure :: var -> annotation -> ResolutionError Reference -> ResolutionFailure var annotation
TermResolutionFailure :: var -> annotation -> ResolutionError Referent -> ResolutionFailure var annotation
getAnnotation :: ResolutionFailure v a -> a
getVar :: ResolutionFailure v a -> v
type ResolutionResult v a r = Either (Seq (ResolutionFailure v a)) r
instance GHC.Show.Show ref => GHC.Show.Show (Unison.Names.ResolutionResult.ResolutionError ref)
instance GHC.Classes.Ord ref => GHC.Classes.Ord (Unison.Names.ResolutionResult.ResolutionError ref)
instance GHC.Classes.Eq ref => GHC.Classes.Eq (Unison.Names.ResolutionResult.ResolutionError ref)
instance (GHC.Show.Show var, GHC.Show.Show annotation) => GHC.Show.Show (Unison.Names.ResolutionResult.ResolutionFailure var annotation)
instance (GHC.Classes.Ord var, GHC.Classes.Ord annotation) => GHC.Classes.Ord (Unison.Names.ResolutionResult.ResolutionFailure var annotation)
instance (GHC.Classes.Eq var, GHC.Classes.Eq annotation) => GHC.Classes.Eq (Unison.Names.ResolutionResult.ResolutionFailure var annotation)

module Unison.Type

-- | Base functor for types in the Unison language
data F a
Ref :: Reference -> F a
Arrow :: a -> a -> F a
Ann :: a -> Kind -> F a
App :: a -> a -> F a
Effect :: a -> a -> F a
Effects :: [a] -> F a
Forall :: a -> F a
IntroOuter :: a -> F a

-- | Types are represented as ABTs over the base functor F, with variables
--   in <tt>v</tt>
type Type v a = Term F v a
wrapV :: Ord v => Type v a -> Type (V v) a
freeVars :: Type v a -> Set v
bindExternal :: Var v => [(v, Reference)] -> Type v a -> Type v a
bindReferences :: Var v => Set v -> Map Name Reference -> Type v a -> ResolutionResult v a (Type v a)
newtype Monotype v a
Monotype :: Type v a -> Monotype v a
[getPolytype] :: Monotype v a -> Type v a
monotype :: Var v => Type v a -> Maybe (Monotype v a)
arity :: Type v a -> Int
pattern Ref' :: Reference -> Term F v a
pattern Arrow' :: Term F v a -> Term F v a -> Term F v a
pattern Arrow'' :: Ord v => Term F v a -> [Type v a] -> Type v a -> Term F v a
pattern Arrows' :: [Type v a] -> Type v a
pattern EffectfulArrows' :: Type v a -> [(Maybe [Type v a], Type v a)] -> Type v a
pattern Ann' :: Term F v a -> Kind -> Term F v a
pattern App' :: Term F v a -> Term F v a -> Term F v a
pattern Apps' :: Type v a -> [Type v a] -> Type v a
pattern Pure' :: Ord v => Type v a -> Type v a
pattern Effects' :: [Term F v a] -> Term F v a
pattern Effect1' :: Term F v a -> Term F v a -> Term F v a
pattern Effect' :: Ord v => [Type v a] -> Type v a -> Type v a
pattern Effect'' :: Ord v => [Type v a] -> Type v a -> Type v a
pattern Effect0' :: Ord v => [Type v a] -> Type v a -> Type v a
pattern Forall' :: Var v => Subst F v a -> Term F v a
pattern IntroOuter' :: Var v => Subst F v a -> Term F v a
pattern IntroOuterNamed' :: v -> Term F v a -> Term F v a
pattern ForallsNamed' :: [v] -> Type v a -> Type v a
pattern ForallNamed' :: v -> Term F v a -> Term F v a
pattern Var' :: forall f v a. v -> Term f v a
pattern Cycle' :: forall f v a. [v] -> Term f v a -> Term f v a
pattern Abs' :: (Foldable f, Functor f, Var v) => Subst f v a -> Term f v a
unPure :: Ord v => Type v a -> Maybe (Type v a)
unArrows :: Type v a -> Maybe [Type v a]
unEffectfulArrows :: Type v a -> Maybe (Type v a, [(Maybe [Type v a], Type v a)])
unApps :: Type v a -> Maybe (Type v a, [Type v a])
unIntroOuters :: Type v a -> Maybe ([v], Type v a)
stripIntroOuters :: Type v a -> Type v a
unForalls :: Type v a -> Maybe ([v], Type v a)
unEffect0 :: Ord v => Type v a -> ([Type v a], Type v a)
unEffects1 :: Ord v => Type v a -> Maybe ([Type v a], Type v a)

-- | True if the given type is a function, possibly quantified
isArrow :: Var v => Type v a -> Bool
ref :: Ord v => a -> Reference -> Type v a
refId :: Ord v => a -> Id -> Type v a
termLink :: Ord v => a -> Type v a
typeLink :: Ord v => a -> Type v a
derivedBase32Hex :: Ord v => Reference -> a -> Type v a
intRef :: Reference
natRef :: Reference
floatRef :: Reference
booleanRef :: Reference
textRef :: Reference
charRef :: Reference
listRef :: Reference
bytesRef :: Reference
effectRef :: Reference
termLinkRef :: Reference
typeLinkRef :: Reference
builtinIORef :: Reference
fileHandleRef :: Reference
filePathRef :: Reference
threadIdRef :: Reference
socketRef :: Reference
scopeRef :: Reference
refRef :: Reference
mvarRef :: Reference
tvarRef :: Reference
tlsRef :: Reference
stmRef :: Reference
tlsClientConfigRef :: Reference
tlsServerConfigRef :: Reference
tlsSignedCertRef :: Reference
tlsPrivateKeyRef :: Reference
tlsCipherRef :: Reference
tlsVersionRef :: Reference
hashAlgorithmRef :: Reference
codeRef :: Reference
valueRef :: Reference
anyRef :: Reference
any :: Ord v => a -> Type v a
builtin :: Ord v => a -> Text -> Type v a
int :: Ord v => a -> Type v a
nat :: Ord v => a -> Type v a
float :: Ord v => a -> Type v a
boolean :: Ord v => a -> Type v a
text :: Ord v => a -> Type v a
char :: Ord v => a -> Type v a
fileHandle :: Ord v => a -> Type v a
threadId :: Ord v => a -> Type v a
builtinIO :: Ord v => a -> Type v a
scopeType :: Ord v => a -> Type v a
refType :: Ord v => a -> Type v a
socket :: Ord v => a -> Type v a
list :: Ord v => a -> Type v a
bytes :: Ord v => a -> Type v a
effectType :: Ord v => a -> Type v a
code :: Ord v => a -> Type v a
value :: Ord v => a -> Type v a
app :: Ord v => a -> Type v a -> Type v a -> Type v a
apps :: Ord v => Type v a -> [(a, Type v a)] -> Type v a
app' :: (Ord v, Semigroup a) => Type v a -> Type v a -> Type v a
apps' :: (Semigroup a, Ord v) => Type v a -> [Type v a] -> Type v a
arrow :: Ord v => a -> Type v a -> Type v a -> Type v a
arrow' :: (Semigroup a, Ord v) => Type v a -> Type v a -> Type v a
ann :: Ord v => a -> Type v a -> Kind -> Type v a
forall :: Ord v => a -> v -> Type v a -> Type v a
introOuter :: Ord v => a -> v -> Type v a -> Type v a
iff :: Var v => Type v ()
iff' :: Var v => a -> Type v a
iff2 :: Var v => a -> Type v a
andor :: Ord v => Type v ()
andor' :: Ord v => a -> Type v a
var :: Ord v => a -> v -> Type v a
v' :: Var v => Text -> Type v ()
av' :: Var v => a -> Text -> Type v a
forall' :: Var v => a -> [Text] -> Type v a -> Type v a
foralls :: Ord v => a -> [v] -> Type v a -> Type v a
arrows :: Ord v => [(a, Type v a)] -> Type v a -> Type v a
effect :: Ord v => a -> [Type v a] -> Type v a -> Type v a
effects :: Ord v => a -> [Type v a] -> Type v a
effect1 :: Ord v => a -> Type v a -> Type v a -> Type v a
flattenEffects :: Type v a -> [Type v a]
effectV :: Ord v => a -> (a, Type v a) -> (a, Type v a) -> Type v a
stripEffect :: Ord v => Type v a -> ([Type v a], Type v a)
flipApply :: Var v => Type v () -> Type v ()
generalize' :: Var v => Type -> Type v a -> Type v a

-- | Bind the given variables with an outer <a>forall</a>, if they are used
--   in <tt>t</tt>.
generalize :: Ord v => [v] -> Type v a -> Type v a
unforall :: Type v a -> Type v a
unforall' :: Type v a -> ([v], Type v a)
dependencies :: Ord v => Type v a -> Set Reference
updateDependencies :: Ord v => Map Reference Reference -> Type v a -> Type v a
usesEffects :: Ord v => Type v a -> Bool
freeEffectVars :: Ord v => Type v a -> Set v
existentializeArrows :: (Ord v, Monad m) => m v -> Type v a -> m (Type v a)
purifyArrows :: Ord v => Type v a -> Type v a
removeEffectVars :: Var v => Set v -> Type v a -> Type v a
removeAllEffectVars :: Var v => Type v a -> Type v a
removePureEffects :: Var v => Type v a -> Type v a
editFunctionResult :: forall v a. Ord v => (Type v a -> Type v a) -> Type v a -> Type v a
functionResult :: Type v a -> Maybe (Type v a)

-- | Bind all free variables (not in <tt>except</tt>) that start with a
--   lowercase letter and are unqualified with an outer <a>forall</a>. `a
--   -&gt; a` becomes ` a . a -&gt; a` `B -&gt; B` becomes `B -&gt; B`
--   (not changed) `.foo -&gt; .foo` becomes `.foo -&gt; .foo` (not
--   changed) `.foo.bar -&gt; blarrg.woot` becomes `.foo.bar -&gt;
--   blarrg.woot` (unchanged)
generalizeLowercase :: Var v => Set v -> Type v a -> Type v a
freeVarsToOuters :: Ord v => Set v -> Type v a -> Type v a

-- | This function removes all variable shadowing from the types and
--   reduces fresh ids to the minimum possible to avoid ambiguity. Useful
--   when showing two different types.
cleanupVars :: Var v => [Type v a] -> [Type v a]
cleanupVarsMap :: Var v => [Type v a] -> Map v v
cleanupVars1' :: Var v => Map v v -> Type v a -> Type v a

-- | This function removes all variable shadowing from the type and reduces
--   fresh ids to the minimum possible to avoid ambiguity.
cleanupVars1 :: Var v => Type v a -> Type v a
cleanupAbilityLists :: Var v => Type v a -> Type v a
cleanups :: Var v => [Type v a] -> [Type v a]
cleanup :: Var v => Type v a -> Type v a
builtinAbilities :: Set Reference
instance Data.Traversable.Traversable Unison.Type.F
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Type.F a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Type.F a)
instance GHC.Generics.Generic1 Unison.Type.F
instance GHC.Generics.Generic (Unison.Type.F a)
instance GHC.Base.Functor Unison.Type.F
instance Data.Foldable.Foldable Unison.Type.F
instance Unison.ABT.Var v => GHC.Classes.Eq (Unison.Type.Monotype v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Type.Monotype v a)
instance Prelude.Extras.Eq1 Unison.Type.F
instance Prelude.Extras.Ord1 Unison.Type.F
instance Prelude.Extras.Show1 Unison.Type.F
instance GHC.Show.Show a => GHC.Show.Show (Unison.Type.F a)

module Unison.Type.Names
bindNames :: Var v => Set v -> Names -> Type v a -> ResolutionResult v a (Type v a)

module Unison.Pattern
data Pattern loc
Unbound :: loc -> Pattern loc
Var :: loc -> Pattern loc
Boolean :: loc -> !Bool -> Pattern loc
Int :: loc -> !Int64 -> Pattern loc
Nat :: loc -> !Word64 -> Pattern loc
Float :: loc -> !Double -> Pattern loc
Text :: loc -> !Text -> Pattern loc
Char :: loc -> !Char -> Pattern loc
Constructor :: loc -> !Reference -> !ConstructorId -> [Pattern loc] -> Pattern loc
As :: loc -> Pattern loc -> Pattern loc
EffectPure :: loc -> Pattern loc -> Pattern loc
EffectBind :: loc -> !Reference -> !ConstructorId -> [Pattern loc] -> Pattern loc -> Pattern loc
SequenceLiteral :: loc -> [Pattern loc] -> Pattern loc
SequenceOp :: loc -> Pattern loc -> !SeqOp -> Pattern loc -> Pattern loc
data SeqOp
Cons :: SeqOp
Snoc :: SeqOp
Concat :: SeqOp
updateDependencies :: Map Referent Referent -> Pattern loc -> Pattern loc
application :: Pattern loc -> Bool
loc :: Pattern loc -> loc
setLoc :: Pattern loc -> loc -> Pattern loc
foldMap' :: Monoid m => (Pattern loc -> m) -> Pattern loc -> m
generalizedDependencies :: Ord r => (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> Pattern loc -> Set r
labeledDependencies :: Pattern loc -> Set LabeledDependency
instance GHC.Generics.Generic Unison.Pattern.SeqOp
instance GHC.Classes.Ord Unison.Pattern.SeqOp
instance GHC.Show.Show Unison.Pattern.SeqOp
instance GHC.Classes.Eq Unison.Pattern.SeqOp
instance Data.Traversable.Traversable Unison.Pattern.Pattern
instance Data.Foldable.Foldable Unison.Pattern.Pattern
instance GHC.Base.Functor Unison.Pattern.Pattern
instance GHC.Generics.Generic (Unison.Pattern.Pattern loc)
instance GHC.Classes.Ord loc => GHC.Classes.Ord (Unison.Pattern.Pattern loc)
instance GHC.Show.Show (Unison.Pattern.Pattern loc)
instance Unison.Hashable.Hashable (Unison.Pattern.Pattern p)
instance GHC.Classes.Eq (Unison.Pattern.Pattern loc)
instance Unison.Hashable.Hashable Unison.Pattern.SeqOp

module Unison.Term
data MatchCase loc a
MatchCase :: Pattern loc -> Maybe a -> a -> MatchCase loc a

-- | Base functor for terms in the Unison language We need <tt>typeVar</tt>
--   because the term and type variables may differ.
data F typeVar typeAnn patternAnn a
Int :: Int64 -> F typeVar typeAnn patternAnn a
Nat :: Word64 -> F typeVar typeAnn patternAnn a
Float :: Double -> F typeVar typeAnn patternAnn a
Boolean :: Bool -> F typeVar typeAnn patternAnn a
Text :: Text -> F typeVar typeAnn patternAnn a
Char :: Char -> F typeVar typeAnn patternAnn a
Blank :: Blank typeAnn -> F typeVar typeAnn patternAnn a
Ref :: Reference -> F typeVar typeAnn patternAnn a
Constructor :: Reference -> ConstructorId -> F typeVar typeAnn patternAnn a
Request :: Reference -> ConstructorId -> F typeVar typeAnn patternAnn a
Handle :: a -> a -> F typeVar typeAnn patternAnn a
App :: a -> a -> F typeVar typeAnn patternAnn a
Ann :: a -> Type typeVar typeAnn -> F typeVar typeAnn patternAnn a
List :: Seq a -> F typeVar typeAnn patternAnn a
If :: a -> a -> a -> F typeVar typeAnn patternAnn a
And :: a -> a -> F typeVar typeAnn patternAnn a
Or :: a -> a -> F typeVar typeAnn patternAnn a
Lam :: a -> F typeVar typeAnn patternAnn a
LetRec :: IsTop -> [a] -> a -> F typeVar typeAnn patternAnn a
Let :: IsTop -> a -> a -> F typeVar typeAnn patternAnn a
Match :: a -> [MatchCase patternAnn a] -> F typeVar typeAnn patternAnn a
TermLink :: Referent -> F typeVar typeAnn patternAnn a
TypeLink :: Reference -> F typeVar typeAnn patternAnn a
type IsTop = Bool

-- | Like `Term v`, but with an annotation of type <tt>a</tt> at every
--   level in the tree
type Term v a = Term2 v a a v a

-- | Allow type variables and term variables to differ
type Term' vt v a = Term2 vt a a v a

-- | Allow type variables, term variables, type annotations and term
--   annotations to all differ
type Term2 vt at ap v a = Term (F vt at ap) v a

-- | Like `Term v a`, but with only () for type and pattern annotations.
type Term3 v a = Term2 v () () v a

-- | Terms are represented as ABTs over the base functor F, with variables
--   in <tt>v</tt>
type Term0 v = Term v ()

-- | Terms with type variables in <tt>vt</tt>, and term variables in
--   <tt>v</tt>
type Term0' vt v = Term' vt v ()
bindNames :: forall v a. Var v => Set v -> Names -> Term v a -> ResolutionResult v a (Term v a)
bindSomeNames :: forall v a. Var v => Set v -> Names -> Term v a -> ResolutionResult v a (Term v a)
prepareTDNR :: Var v => Term (F vt b ap) v b -> Term (F vt b ap) v b
amap :: Ord v => (a -> a2) -> Term v a -> Term v a2
patternMap :: (Pattern ap -> Pattern ap2) -> Term2 vt at ap v a -> Term2 vt at ap2 v a
vmap :: Ord v2 => (v -> v2) -> Term v a -> Term v2 a
vtmap :: Ord vt2 => (vt -> vt2) -> Term' vt v a -> Term' vt2 v a
typeMap :: Ord vt2 => (Type vt at -> Type vt2 at2) -> Term2 vt at ap v a -> Term2 vt2 at2 ap v a
extraMap' :: (Ord vt, Ord vt') => (vt -> vt') -> (at -> at') -> (ap -> ap') -> Term2 vt at ap v a -> Term2 vt' at' ap' v a
extraMap :: (Ord vt, Ord vt') => (vt -> vt') -> (at -> at') -> (ap -> ap') -> F vt at ap a -> F vt' at' ap' a
matchCaseExtraMap :: (loc -> loc') -> MatchCase loc a -> MatchCase loc' a
unannotate :: forall vt at ap v a. Ord v => Term2 vt at ap v a -> Term0' vt v
wrapV :: Ord v => Term v a -> Term (V v) a

-- | All variables mentioned in the given term. Includes both term and type
--   variables, both free and bound.
allVars :: Ord v => Term v a -> Set v
freeVars :: Term' vt v a -> Set v
freeTypeVars :: Ord vt => Term' vt v a -> Set vt
freeTypeVarAnnotations :: Ord vt => Term' vt v a -> Map vt [a]
substTypeVars :: (Ord v, Var vt) => [(vt, Type vt b)] -> Term' vt v a -> Term' vt v a
substTypeVar :: (Ord v, Var vt) => vt -> Type vt b -> Term' vt v a -> Term' vt v a
renameTypeVar :: (Ord v, Var vt) => vt -> vt -> Term' vt v a -> Term' vt v a
generalizeTypeSignatures :: (Var vt, Var v) => Term' vt v a -> Term' vt v a
pattern Var' :: forall f v a. v -> Term f v a
pattern Cycle' :: forall f v a. [v] -> Term f v a -> Term f v a
pattern Abs' :: (Foldable f, Functor f, Var v) => Subst f v a -> Term f v a
pattern Int' :: Int64 -> Term (F typeVar typeAnn patternAnn) v a
pattern Nat' :: Word64 -> Term (F typeVar typeAnn patternAnn) v a
pattern Float' :: Double -> Term (F typeVar typeAnn patternAnn) v a
pattern Boolean' :: Bool -> Term (F typeVar typeAnn patternAnn) v a
pattern Text' :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Char' :: Char -> Term (F typeVar typeAnn patternAnn) v a
pattern Blank' :: forall typeVar typeAnn patternAnn v a. Blank typeAnn -> Term (F typeVar typeAnn patternAnn) v a
pattern Ref' :: Reference -> Term (F typeVar typeAnn patternAnn) v a
pattern TermLink' :: Referent -> Term (F typeVar typeAnn patternAnn) v a
pattern TypeLink' :: Reference -> Term (F typeVar typeAnn patternAnn) v a
pattern Builtin' :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern App' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Match' :: Term (F typeVar typeAnn patternAnn) v a -> [MatchCase patternAnn (Term (F typeVar typeAnn patternAnn) v a)] -> Term (F typeVar typeAnn patternAnn) v a
pattern Constructor' :: Reference -> ConstructorId -> Term (F typeVar typeAnn patternAnn) v a
pattern Request' :: Reference -> ConstructorId -> Term (F typeVar typeAnn patternAnn) v a
pattern RequestOrCtor' :: Reference -> ConstructorId -> Term2 vt at ap v a
pattern If' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern And' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Or' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Handle' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Apps' :: Term2 vt at ap v a -> [Term2 vt at ap v a] -> Term2 vt at ap v a
pattern AppsPred' :: Term2 vt at ap v a -> [Term2 vt at ap v a] -> (Term2 vt at ap v a, Term2 vt at ap v a -> Bool)
pattern BinaryApp' :: Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern BinaryApps' :: [(Term2 vt at ap v a, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern BinaryAppsPred' :: [(Term2 vt at ap v a, Term2 vt at ap v a)] -> Term2 vt at ap v a -> (Term2 vt at ap v a, Term2 vt at ap v a -> Bool)
pattern Ann' :: Term (F typeVar typeAnn patternAnn) v a -> Type typeVar typeAnn -> Term (F typeVar typeAnn patternAnn) v a
pattern List' :: Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term (F typeVar typeAnn patternAnn) v a
pattern Lam' :: Var v => Subst (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Delay' :: Ord v => Term2 vt at ap v a -> Term2 vt at ap v a
unDelay :: Ord v => Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
pattern LamNamed' :: forall typeVar typeAnn patternAnn v a. v -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern LamsNamed' :: forall vt at ap v a. [v] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LamsNamedOpt' :: forall vt at ap v a. [v] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LamsNamedPred' :: forall vt at ap v a. [v] -> Term2 vt at ap v a -> (Term2 vt at ap v a, v -> Bool)
pattern LamsNamedOrDelay' :: Var v => [v] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern Let1' :: Var v => Term' vt v a -> Subst (F vt a a) v a -> Term' vt v a
pattern Let1Top' :: Var v => IsTop -> Term' vt v a -> Subst (F vt a a) v a -> Term' vt v a
pattern Let1Named' :: forall typeVar typeAnn patternAnn v a. v -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Let1NamedTop' :: forall typeVar typeAnn patternAnn v a. IsTop -> v -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Lets' :: forall vt at ap v a. [(IsTop, v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LetRecNamed' :: forall vt at ap v a. [(v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LetRecNamedTop' :: forall vt at ap v a. IsTop -> [(v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LetRec' :: (Monad m, Var v) => ((v -> m v) -> m ([(v, Term2 vt at ap v a)], Term2 vt at ap v a)) -> Term2 vt at ap v a
pattern LetRecTop' :: (Monad m, Var v) => IsTop -> ((v -> m v) -> m ([(v, Term2 vt at ap v a)], Term2 vt at ap v a)) -> Term2 vt at ap v a
pattern LetRecNamedAnnotated' :: forall vt v a. a -> [((a, v), Term' vt v a)] -> Term' vt v a -> Term' vt v a
pattern LetRecNamedAnnotatedTop' :: forall vt v a. IsTop -> a -> [((a, v), Term' vt v a)] -> Term' vt v a -> Term' vt v a
fresh :: Var v => Term0 v -> v -> v
var :: a -> v -> Term2 vt at ap v a
var' :: Var v => Text -> Term0' vt v
ref :: Ord v => a -> Reference -> Term2 vt at ap v a
pattern Referent' :: Referent -> Term2 vt at ap v a
unReferent :: Term2 vt at ap v a -> Maybe Referent
refId :: Ord v => a -> Id -> Term2 vt at ap v a
termLink :: Ord v => a -> Referent -> Term2 vt at ap v a
typeLink :: Ord v => a -> Reference -> Term2 vt at ap v a
builtin :: Ord v => a -> Text -> Term2 vt at ap v a
float :: Ord v => a -> Double -> Term2 vt at ap v a
boolean :: Ord v => a -> Bool -> Term2 vt at ap v a
int :: Ord v => a -> Int64 -> Term2 vt at ap v a
nat :: Ord v => a -> Word64 -> Term2 vt at ap v a
text :: Ord v => a -> Text -> Term2 vt at ap v a
char :: Ord v => a -> Char -> Term2 vt at ap v a
watch :: (Var v, Semigroup a) => a -> String -> Term v a -> Term v a
watchMaybe :: (Var v, Semigroup a) => Maybe String -> Term v a -> Term v a
blank :: Ord v => a -> Term2 vt at ap v a
placeholder :: Ord v => a -> String -> Term2 vt a ap v a
resolve :: Ord v => at -> ab -> String -> Term2 vt ab ap v at
constructor :: Ord v => a -> Reference -> ConstructorId -> Term2 vt at ap v a
request :: Ord v => a -> Reference -> ConstructorId -> Term2 vt at ap v a
app_ :: Ord v => Term0' vt v -> Term0' vt v -> Term0' vt v
app :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
match :: Ord v => a -> Term2 vt at a v a -> [MatchCase a (Term2 vt at a v a)] -> Term2 vt at a v a
handle :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
and :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
or :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
list :: Ord v => a -> [Term2 vt at ap v a] -> Term2 vt at ap v a
list' :: Ord v => a -> Seq (Term2 vt at ap v a) -> Term2 vt at ap v a
apps :: Ord v => Term2 vt at ap v a -> [(a, Term2 vt at ap v a)] -> Term2 vt at ap v a
apps' :: (Ord v, Semigroup a) => Term2 vt at ap v a -> [Term2 vt at ap v a] -> Term2 vt at ap v a
iff :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
ann_ :: Ord v => Term0' vt v -> Type vt () -> Term0' vt v
ann :: Ord v => a -> Term2 vt at ap v a -> Type vt at -> Term2 vt at ap v a
lam :: Ord v => a -> v -> Term2 vt at ap v a -> Term2 vt at ap v a
delay :: Var v => a -> Term2 vt at ap v a -> Term2 vt at ap v a
lam' :: Ord v => a -> [v] -> Term2 vt at ap v a -> Term2 vt at ap v a
lam'' :: Ord v => [(a, v)] -> Term2 vt at ap v a -> Term2 vt at ap v a
isLam :: Term2 vt at ap v a -> Bool
arity :: Term2 vt at ap v a -> Int
unLetRecNamedAnnotated :: Term' vt v a -> Maybe (IsTop, a, [((a, v), Term' vt v a)], Term' vt v a)
letRec' :: (Ord v, Monoid a) => Bool -> [(v, Term' vt v a)] -> Term' vt v a -> Term' vt v a
consLetRec :: Ord v => Bool -> a -> (a, v, Term' vt v a) -> Term' vt v a -> Term' vt v a
letRec :: Ord v => Bool -> a -> [((a, v), Term' vt v a)] -> Term' vt v a -> Term' vt v a

-- | Smart constructor for let rec blocks. Each binding in the block may
--   reference any other binding in the block in its body (including
--   itself), and the output expression may also reference any binding in
--   the block.
letRec_ :: Ord v => IsTop -> [(v, Term0' vt v)] -> Term0' vt v -> Term0' vt v

-- | Smart constructor for let blocks. Each binding in the block may
--   reference only previous bindings in the block, not including itself.
--   The output expression may reference any binding in the block. todo:
--   delete me
let1_ :: Ord v => IsTop -> [(v, Term0' vt v)] -> Term0' vt v -> Term0' vt v

-- | annotations are applied to each nested Let expression
let1 :: Ord v => IsTop -> [((a, v), Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
let1' :: (Semigroup a, Ord v) => IsTop -> [(v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
unLet1 :: Var v => Term' vt v a -> Maybe (IsTop, Term' vt v a, Subst (F vt a a) v a)

-- | Satisfies `unLet (let' bs e) == Just (bs, e)`
unLet :: Term2 vt at ap v a -> Maybe ([(IsTop, v, Term2 vt at ap v a)], Term2 vt at ap v a)

-- | Satisfies `unLetRec (letRec bs e) == Just (bs, e)`
unLetRecNamed :: Term2 vt at ap v a -> Maybe (IsTop, [(v, Term2 vt at ap v a)], Term2 vt at ap v a)
unLetRec :: (Monad m, Var v) => Term2 vt at ap v a -> Maybe (IsTop, (v -> m v) -> m ([(v, Term2 vt at ap v a)], Term2 vt at ap v a))
unApps :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, [Term2 vt at ap v a])
unAppsPred :: (Term2 vt at ap v a, Term2 vt at ap v a -> Bool) -> Maybe (Term2 vt at ap v a, [Term2 vt at ap v a])
unBinaryApp :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a, Term2 vt at ap v a)
unBinaryApps :: Term2 vt at ap v a -> Maybe ([(Term2 vt at ap v a, Term2 vt at ap v a)], Term2 vt at ap v a)
unBinaryAppsPred :: (Term2 vt at ap v a, Term2 vt at ap v a -> Bool) -> Maybe ([(Term2 vt at ap v a, Term2 vt at ap v a)], Term2 vt at ap v a)
unLams' :: Term2 vt at ap v a -> Maybe ([v], Term2 vt at ap v a)
unLamsOpt' :: Term2 vt at ap v a -> Maybe ([v], Term2 vt at ap v a)
unLamsUntilDelay' :: Var v => Term2 vt at ap v a -> Maybe ([v], Term2 vt at ap v a)
unLamsPred' :: (Term2 vt at ap v a, v -> Bool) -> Maybe ([v], Term2 vt at ap v a)
unReqOrCtor :: Term2 vt at ap v a -> Maybe (Reference, ConstructorId)
dependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference
termDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference
typeDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference
constructorDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference
generalizedDependencies :: (Ord v, Ord vt, Ord r) => (Reference -> r) -> (Reference -> r) -> (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> Term2 vt at ap v a -> Set r
labeledDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set LabeledDependency
updateDependencies :: Ord v => Map Referent Referent -> Map Reference Reference -> Term v a -> Term v a

-- | If the outermost term is a function application, perform substitution
--   of the argument into the body
betaReduce :: Var v => Term0 v -> Term0 v
betaNormalForm :: Var v => Term0 v -> Term0 v
etaNormalForm :: Ord v => Term0 v -> Term0 v
etaReduceEtaVars :: Var v => Term0 v -> Term0 v
unhashComponent :: forall v a. Var v => Map Reference (Term v a) -> Map Reference (v, Term v a)
fromReferent :: Ord v => a -> Referent -> Term2 vt at ap v a
instance Data.Traversable.Traversable (Unison.Term.MatchCase loc)
instance GHC.Generics.Generic1 (Unison.Term.MatchCase loc)
instance GHC.Generics.Generic (Unison.Term.MatchCase loc a)
instance GHC.Base.Functor (Unison.Term.MatchCase loc)
instance Data.Foldable.Foldable (Unison.Term.MatchCase loc)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Term.MatchCase loc a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Term.MatchCase loc a)
instance Data.Traversable.Traversable (Unison.Term.F typeVar typeAnn patternAnn)
instance GHC.Generics.Generic1 (Unison.Term.F typeVar typeAnn patternAnn)
instance GHC.Generics.Generic (Unison.Term.F typeVar typeAnn patternAnn a)
instance GHC.Base.Functor (Unison.Term.F typeVar typeAnn patternAnn)
instance Data.Foldable.Foldable (Unison.Term.F typeVar typeAnn patternAnn)
instance (GHC.Classes.Eq a, Unison.ABT.Var v) => Prelude.Extras.Eq1 (Unison.Term.F v a p)
instance GHC.Show.Show v => Prelude.Extras.Show1 (Unison.Term.F v a p)
instance (Unison.ABT.Var vt, GHC.Classes.Eq at, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Term.F vt at p a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Term.F v a0 p a)

module Unison.Paths
type Type v = Type v ()
type Term v = Term v ()
data Target v
Term :: Term v -> Target v
Type :: Type v -> Target v
Var :: v -> Target v
Declaration :: v -> Term v -> Target v
vmap :: Ord v2 => (v -> v2) -> Target v -> Target v2
data PathElement

-- | Points at function in a function/type application
Fn :: PathElement

-- | Points at the argument of a function/type application
Arg :: PathElement

-- | Points at the body of a lambda, let, binding, forall, or annotation
Body :: PathElement

-- | Points at the symbol bound by a `let`, <tt>lambda</tt> or
--   <tt>forall</tt> binder
Bound :: PathElement

-- | Points at a particular binding in a let
Binding :: !Int -> PathElement

-- | Points at the index of a vector
Index :: !Int -> PathElement

-- | Points into the annotation
Annotation :: PathElement

-- | Points at the left of an <tt>Arrow</tt>
Input :: PathElement

-- | Points at the right of an <tt>Arrow</tt>
Output :: PathElement
focus1 :: Var v => PathElement -> Path (Target v) (Target (V v)) (Target v) (Target (V v)) [v]
type Path = [PathElement]
focus :: Var v => Path -> Target v -> Maybe (Target v, Target (V v) -> Maybe (Target v), [v])
at :: Var v => Path -> Target v -> Maybe (Target v)
atTerm :: Var v => Path -> Term v -> Maybe (Term v)
atType :: Var v => Path -> Type v -> Maybe (Type v)
modify :: Var v => (Target v -> Target (V v)) -> Path -> Target v -> Maybe (Target v)
modifyTerm :: Var v => (Term v -> Term (V v)) -> Path -> Term v -> Maybe (Term v)
modifyTerm' :: Var v => (Term v -> Term (V v)) -> Path -> Term v -> Term v
modifyType :: Var v => (Type v -> Type (V v)) -> Path -> Type v -> Maybe (Type v)
inScopeAt :: Var v => Path -> Target v -> [v]
inScopeAtTerm :: Var v => Path -> Term v -> [v]
inScopeAtType :: Var v => Path -> Type v -> [v]
insertTerm :: Var v => Path -> Term v -> Maybe (Term v)

-- | Return the list of all prefixes of the input path
pathPrefixes :: Path -> [Path]

-- | Add an element onto the end of this <a>Path</a>
pathExtend :: PathElement -> Path -> Path
parent :: Path -> Maybe Path
parent' :: Path -> Path
asTerm :: Target v -> Maybe (Term v)
asType :: Target v -> Maybe (Type v)
asVar :: Target v -> Maybe v
asDeclaration :: Target v -> Maybe (v, Term v)
instance GHC.Generics.Generic (Unison.Paths.Target v)
instance GHC.Generics.Generic Unison.Paths.PathElement
instance GHC.Show.Show Unison.Paths.PathElement
instance GHC.Classes.Ord Unison.Paths.PathElement
instance GHC.Classes.Eq Unison.Paths.PathElement

module Unison.DataDeclaration
data DataDeclaration v a
DataDeclaration :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> DataDeclaration v a
[modifier] :: DataDeclaration v a -> Modifier
[annotation] :: DataDeclaration v a -> a
[bound] :: DataDeclaration v a -> [v]
[constructors'] :: DataDeclaration v a -> [(a, v, Type v a)]
newtype EffectDeclaration v a
EffectDeclaration :: DataDeclaration v a -> EffectDeclaration v a
[toDataDecl] :: EffectDeclaration v a -> DataDeclaration v a
type Decl v a = Either (EffectDeclaration v a) (DataDeclaration v a)
data DeclOrBuiltin v a
Builtin :: ConstructorType -> DeclOrBuiltin v a
Decl :: Decl v a -> DeclOrBuiltin v a
data Modifier
Structural :: Modifier
Unique :: Text -> Modifier

-- | All variables mentioned in the given data declaration. Includes both
--   term and type variables, both free and bound.
allVars :: Ord v => DataDeclaration v a -> Set v
asDataDecl :: Decl v a -> DataDeclaration v a
bindReferences :: Var v => Set v -> Map Name Reference -> DataDeclaration v a -> ResolutionResult v a (DataDeclaration v a)
constructorNames :: Var v => DataDeclaration v a -> [Text]
constructors :: DataDeclaration v a -> [(v, Type v a)]
constructorType :: Decl v a -> ConstructorType
constructorTypes :: DataDeclaration v a -> [Type v a]
constructorVars :: DataDeclaration v a -> [v]
declConstructorReferents :: Id -> Decl v a -> [Id]
declDependencies :: Ord v => Decl v a -> Set Reference
declFields :: Var v => Decl v a -> Either [Int] [Int]
dependencies :: Ord v => DataDeclaration v a -> Set Reference
generateRecordAccessors :: (Semigroup a, Var v) => [(v, a)] -> v -> Reference -> [(v, Term v a)]

-- | This converts <a>Reference</a>s it finds that are in the input
--   <a>Map</a> back to free variables.
--   
--   In the result map, any of the references inside the Decls which are
--   keys of the input map; have been replaced with the corresponding
--   output <tt>v</tt>s in the output <a>Decl</a>s, which are fresh with
--   respect to all input Decls.
unhashComponent :: forall v a. Var v => Map Reference (Decl v a) -> Map Reference (v, Decl v a)
mkDataDecl' :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> DataDeclaration v a
mkEffectDecl' :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> EffectDeclaration v a
typeOfConstructor :: DataDeclaration v a -> ConstructorId -> Maybe (Type v a)
withEffectDeclM :: Functor f => (DataDeclaration v a -> f (DataDeclaration v' a')) -> EffectDeclaration v a -> f (EffectDeclaration v' a')
amap :: (a -> a2) -> Decl v a -> Decl v a2
updateDependencies :: Ord v => Map Reference Reference -> Decl v a -> Decl v a
instance GHC.Show.Show Unison.DataDeclaration.Modifier
instance GHC.Classes.Ord Unison.DataDeclaration.Modifier
instance GHC.Classes.Eq Unison.DataDeclaration.Modifier
instance GHC.Base.Functor (Unison.DataDeclaration.DataDeclaration v)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.DataDeclaration.DataDeclaration v a)
instance (GHC.Classes.Eq a, Unison.ABT.Var v) => GHC.Classes.Eq (Unison.DataDeclaration.DataDeclaration v a)
instance GHC.Base.Functor (Unison.DataDeclaration.EffectDeclaration v)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.DataDeclaration.EffectDeclaration v a)
instance (Unison.ABT.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.DataDeclaration.EffectDeclaration v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.DataDeclaration.DeclOrBuiltin v a)
instance (Unison.ABT.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.DataDeclaration.DeclOrBuiltin v a)
instance Prelude.Extras.Show1 Unison.DataDeclaration.F
instance GHC.Show.Show a => GHC.Show.Show (Unison.DataDeclaration.F a)
instance Data.Foldable.Foldable Unison.DataDeclaration.F
instance GHC.Base.Functor Unison.DataDeclaration.F

module Unison.DataDeclaration.Names
bindNames :: Var v => Set v -> Names -> DataDeclaration v a -> ResolutionResult v a (DataDeclaration v a)
dataDeclToNames' :: Var v => (v, (Id, DataDeclaration v a)) -> Names
effectDeclToNames' :: Var v => (v, (Id, EffectDeclaration v a)) -> Names
