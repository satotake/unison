-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-util
@version 0.0.0

module U.Util.Alternative
whenM :: (Monad m, Alternative m) => m Bool -> a -> m a

module U.Util.Base32Hex
newtype Base32Hex
UnsafeBase32Hex :: Text -> Base32Hex
[toText] :: Base32Hex -> Text

-- | Return the lowercase unpadded base32Hex encoding of this
--   <a>ByteString</a>. Multibase prefix would be <tt>v</tt>, see
--   <a>https://github.com/multiformats/multibase</a>
fromByteString :: ByteString -> Base32Hex

-- | Produce a <tt>Hash</tt> from a base32hex-encoded version of its binary
--   representation
toByteString :: Base32Hex -> ByteString
instance GHC.Show.Show U.Util.Base32Hex.Base32Hex
instance GHC.Classes.Ord U.Util.Base32Hex.Base32Hex
instance GHC.Classes.Eq U.Util.Base32Hex.Base32Hex

module U.Util.Cache
data Cache k v
Cache :: (k -> IO (Maybe v)) -> (k -> v -> IO ()) -> Cache k v
[lookup_] :: Cache k v -> k -> IO (Maybe v)
[insert_] :: Cache k v -> k -> v -> IO ()
lookup :: MonadIO m => Cache k v -> k -> m (Maybe v)
insert :: MonadIO m => Cache k v -> k -> v -> m ()
cache :: (MonadIO m, Ord k) => m (Cache k v)
nullCache :: Cache k v
semispaceCache :: (MonadIO m, Ord k) => Word -> m (Cache k v)
apply :: MonadIO m => Cache k v -> (k -> m v) -> k -> m v
applyDefined :: (MonadIO m, Applicative g, Traversable g) => Cache k v -> (k -> m (g v)) -> k -> m (g v)

module U.Util.Components

-- | Order bindings by dependencies and group into components. Each
--   component consists of &gt; 1 bindings, each of which depends
--   transitively on all other bindings in the component.
--   
--   1-element components may or may not depend on themselves.
--   
--   The order is such that a component at index i will not depend on
--   components and indexes &gt; i. But a component at index i does not
--   _necessarily_ depend on any components at earlier indices.
--   
--   Example:
--   
--   let rec ping n = pong (n + 1); pong n = ping (n + 1); g = id 42; y =
--   id "hi" id x = x; in ping g
--   
--   <a>components</a> would produce `[[ping,pong], [id], [g], [y]]` Notice
--   that <a>id</a> comes before <tt>g</tt> and <tt>y</tt> in the output,
--   since both <tt>g</tt> and <tt>y</tt> depend on <a>id</a>.
--   
--   Uses Tarjan's algorithm:
--   <a>https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</a>
components :: Ord v => (t -> Set v) -> [(v, t)] -> [[(v, t)]]

module U.Util.Hash

-- | Hash which uniquely identifies a Unison type or term
newtype Hash
Hash :: ShortByteString -> Hash
[toShort] :: Hash -> ShortByteString
toBase32Hex :: Hash -> Base32Hex
fromBase32Hex :: Base32Hex -> Hash
toBytes :: Hash -> ByteString
fromBytes :: ByteString -> Hash
instance GHC.Generics.Generic U.Util.Hash.Hash
instance GHC.Classes.Ord U.Util.Hash.Hash
instance GHC.Classes.Eq U.Util.Hash.Hash
instance GHC.Show.Show U.Util.Hash.Hash

module U.Util.Lens
type Field1' s a = Field1 s s a a
type Field2' s a = Field2 s s a a
type Field3' s a = Field3 s s a a
type Field4' s a = Field4 s s a a

module U.Util.Map
bimap :: Ord a' => (a -> a') -> (b -> b') -> Map a b -> Map a' b'
bitraverse :: (Applicative f, Ord a') => (a -> f a') -> (b -> f b') -> Map a b -> f (Map a' b')

module U.Util.Monoid
intercalateMap :: (Foldable t, Monoid a) => a -> (b -> a) -> t b -> a
fromMaybe :: Monoid a => Maybe a -> a
whenM :: Monoid a => Bool -> a -> a
unlessM :: Monoid a => Bool -> a -> a
isEmpty :: (Eq a, Monoid a) => a -> Bool
nonEmpty :: (Eq a, Monoid a) => a -> Bool
foldMapM :: (Monad m, Foldable f, Monoid b) => (a -> m b) -> f a -> m b

module U.Util.Set
traverse :: (Applicative f, Ord b) => (a -> f b) -> Set a -> f (Set b)
mapMaybe :: Ord b => (a -> Maybe b) -> Set a -> Set b

module U.Util.Text

-- | remove however many spaces prefix all of the lines of the input e.g.
--   stripMargin [here| def foo: blah blah |] == [here| def foo: blah blah
--   |]T
stripMargin :: Text -> Text

module U.Util.String
stripMargin :: String -> String

module U.Util.Timing
enabled :: Bool
time :: MonadIO m => String -> m a -> m a
unsafeTime :: Monad m => String -> m a -> m a
