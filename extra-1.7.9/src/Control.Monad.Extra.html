<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- | Extra functions for &quot;Control.Monad&quot;.</span><span>
</span><span id="line-4"></span><span class="hs-comment">--   These functions provide looping, list operations and booleans.</span><span>
</span><span id="line-5"></span><span class="hs-comment">--   If you need a wider selection of monad loops and list generalisations,</span><span>
</span><span id="line-6"></span><span class="hs-comment">--   see &lt;https://hackage.haskell.org/package/monad-loops monad-loops&gt;.</span><span>
</span><span id="line-7"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Control.Monad.Extra</span><span class="hs-special">(</span><span>
</span><span id="line-8"></span><span>    </span><span class="hs-keyword">module</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span class="hs-special">,</span><span>
</span><span id="line-9"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#whenJust"><span class="hs-identifier">whenJust</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#whenJustM"><span class="hs-identifier">whenJustM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-10"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#pureIf"><span class="hs-identifier">pureIf</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#whenMaybe"><span class="hs-identifier">whenMaybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#whenMaybeM"><span class="hs-identifier">whenMaybeM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#unit"><span class="hs-keyword">unit</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-13"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier">maybeM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#fromMaybeM"><span class="hs-identifier">fromMaybeM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#eitherM"><span class="hs-identifier">eitherM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-14"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Loops</span></span><span>
</span><span id="line-15"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#loop"><span class="hs-identifier">loop</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#loopM"><span class="hs-identifier">loopM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#whileM"><span class="hs-identifier">whileM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#whileJustM"><span class="hs-identifier">whileJustM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#untilJustM"><span class="hs-identifier">untilJustM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-16"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Lists</span></span><span>
</span><span id="line-17"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier">partitionM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-identifier">concatMapM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#concatForM"><span class="hs-identifier">concatForM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#mconcatMapM"><span class="hs-identifier">mconcatMapM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#mapMaybeM"><span class="hs-identifier">mapMaybeM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#findM"><span class="hs-identifier">findM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier">firstJustM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier">fold1M</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#fold1M_"><span class="hs-identifier">fold1M_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-19"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Booleans</span></span><span>
</span><span id="line-20"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#whenM"><span class="hs-identifier">whenM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#unlessM"><span class="hs-identifier">unlessM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier">ifM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#notM"><span class="hs-identifier">notM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#%7C%7C%5E"><span class="hs-operator">(||^)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#%26%26%5E"><span class="hs-operator">(&amp;&amp;^)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#orM"><span class="hs-identifier">orM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#andM"><span class="hs-identifier">andM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#anyM"><span class="hs-identifier">anyM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#allM"><span class="hs-identifier">allM</span></a></span><span>
</span><span id="line-21"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Exception.Extra.html"><span class="hs-identifier">Control.Exception.Extra</span></a></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Monoid</span></span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span class="hs-comment">-- General utilities</span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-comment">-- | Perform some operation on 'Just', given the field inside the 'Just'.</span><span>
</span><span id="line-33"></span><span class="hs-comment">--</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- &gt; whenJust Nothing  print == pure ()</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- &gt; whenJust (Just 1) print == print 1</span><span>
</span><span id="line-36"></span><span id="local-6989586621679053177"><span id="local-6989586621679053178"><span class="annot"><a href="Control.Monad.Extra.html#whenJust"><span class="hs-identifier hs-type">whenJust</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679053178"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053177"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053177"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053178"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053178"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-37"></span><span id="whenJust"><span class="annot"><span class="annottext">whenJust :: Maybe a -&gt; (a -&gt; m ()) -&gt; m ()
</span><a href="Control.Monad.Extra.html#whenJust"><span class="hs-identifier hs-var hs-var">whenJust</span></a></span></span><span> </span><span id="local-6989586621679053176"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679053176"><span class="hs-identifier hs-var">mg</span></a></span></span><span> </span><span id="local-6989586621679053175"><span class="annot"><span class="annottext">a -&gt; m ()
</span><a href="#local-6989586621679053175"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m () -&gt; (a -&gt; m ()) -&gt; Maybe a -&gt; m ()
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; m ()
</span><a href="#local-6989586621679053175"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679053176"><span class="hs-identifier hs-var">mg</span></a></span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-comment">-- | Like 'whenJust', but where the test can be monadic.</span><span>
</span><span id="line-40"></span><span id="local-6989586621679053172"><span id="local-6989586621679053173"><span class="annot"><a href="Control.Monad.Extra.html#whenJustM"><span class="hs-identifier hs-type">whenJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053173"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053173"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053172"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053172"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053173"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053173"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-41"></span><span class="hs-comment">-- Can't reuse whenMaybe on GHC 7.8 or lower because Monad does not imply Applicative</span><span>
</span><span id="line-42"></span><span id="whenJustM"><span class="annot"><span class="annottext">whenJustM :: m (Maybe a) -&gt; (a -&gt; m ()) -&gt; m ()
</span><a href="Control.Monad.Extra.html#whenJustM"><span class="hs-identifier hs-var hs-var">whenJustM</span></a></span></span><span> </span><span id="local-6989586621679053171"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053171"><span class="hs-identifier hs-var">mg</span></a></span></span><span> </span><span id="local-6989586621679053170"><span class="annot"><span class="annottext">a -&gt; m ()
</span><a href="#local-6989586621679053170"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m () -&gt; (a -&gt; m ()) -&gt; m (Maybe a) -&gt; m ()
forall (m :: * -&gt; *) b a.
Monad m =&gt;
m b -&gt; (a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
</span><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-var">maybeM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; m ()
</span><a href="#local-6989586621679053170"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053171"><span class="hs-identifier hs-var">mg</span></a></span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-comment">-- | Return either a `pure` value if a condition is `True`, otherwise `empty`.</span><span>
</span><span id="line-45"></span><span class="hs-comment">--</span><span>
</span><span id="line-46"></span><span class="hs-comment">-- &gt; pureIf @Maybe True  5 == Just 5</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- &gt; pureIf @Maybe False 5 == Nothing</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- &gt; pureIf @[]    True  5 == [5]</span><span>
</span><span id="line-49"></span><span class="hs-comment">-- &gt; pureIf @[]    False 5 == []</span><span>
</span><span id="line-50"></span><span id="local-6989586621679053168"><span id="local-6989586621679053169"><span class="annot"><a href="Control.Monad.Extra.html#pureIf"><span class="hs-identifier hs-type">pureIf</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679053169"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053168"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053169"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053168"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-51"></span><span id="pureIf"><span class="annot"><span class="annottext">pureIf :: Bool -&gt; a -&gt; m a
</span><a href="Control.Monad.Extra.html#pureIf"><span class="hs-identifier hs-var hs-var">pureIf</span></a></span></span><span> </span><span id="local-6989586621679053167"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053167"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679053166"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053166"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053167"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053166"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><span class="hs-identifier hs-var">empty</span></span><span>
</span><span id="line-52"></span><span>
</span><span id="line-53"></span><span class="hs-comment">-- | Like 'when', but return either 'Nothing' if the predicate was 'False',</span><span>
</span><span id="line-54"></span><span class="hs-comment">--   of 'Just' with the result of the computation.</span><span>
</span><span id="line-55"></span><span class="hs-comment">--</span><span>
</span><span id="line-56"></span><span class="hs-comment">-- &gt; whenMaybe True  (print 1) == fmap Just (print 1)</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- &gt; whenMaybe False (print 1) == pure Nothing</span><span>
</span><span id="line-58"></span><span id="local-6989586621679053163"><span id="local-6989586621679053164"><span class="annot"><a href="Control.Monad.Extra.html#whenMaybe"><span class="hs-identifier hs-type">whenMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679053164"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053164"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053163"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053164"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053163"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-59"></span><span id="whenMaybe"><span class="annot"><span class="annottext">whenMaybe :: Bool -&gt; m a -&gt; m (Maybe a)
</span><a href="Control.Monad.Extra.html#whenMaybe"><span class="hs-identifier hs-var hs-var">whenMaybe</span></a></span></span><span> </span><span id="local-6989586621679053162"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053162"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679053161"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053161"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053162"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; m a -&gt; m (Maybe a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053161"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span class="hs-comment">-- | Like 'whenMaybe', but where the test can be monadic.</span><span>
</span><span id="line-62"></span><span id="local-6989586621679053158"><span id="local-6989586621679053159"><span class="annot"><a href="Control.Monad.Extra.html#whenMaybeM"><span class="hs-identifier hs-type">whenMaybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053159"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053159"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053159"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053158"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053159"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053158"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-63"></span><span class="hs-comment">-- Can't reuse whenMaybe on GHC 7.8 or lower because Monad does not imply Applicative</span><span>
</span><span id="line-64"></span><span id="whenMaybeM"><span class="annot"><span class="annottext">whenMaybeM :: m Bool -&gt; m a -&gt; m (Maybe a)
</span><a href="Control.Monad.Extra.html#whenMaybeM"><span class="hs-identifier hs-var hs-var">whenMaybeM</span></a></span></span><span> </span><span id="local-6989586621679053157"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053157"><span class="hs-identifier hs-var">mb</span></a></span></span><span> </span><span id="local-6989586621679053156"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053156"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-65"></span><span>    </span><span id="local-6989586621679053155"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053155"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053157"><span class="hs-identifier hs-var">mb</span></a></span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053155"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; m a -&gt; m (Maybe a)
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053156"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span class="hs-comment">-- | The identity function which requires the inner argument to be @()@. Useful for functions</span><span>
</span><span id="line-69"></span><span class="hs-comment">--   with overloaded return types.</span><span>
</span><span id="line-70"></span><span class="hs-comment">--</span><span>
</span><span id="line-71"></span><span class="hs-comment">-- &gt; \(x :: Maybe ()) -&gt; unit x == x</span><span>
</span><span id="line-72"></span><span id="local-6989586621679053153"><span class="annot"><a href="Control.Monad.Extra.html#unit"><span class="hs-keyword hs-type">unit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679053153"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053153"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-73"></span><span id="unit"><span class="annot"><span class="annottext">unit :: m () -&gt; m ()
</span><a href="Control.Monad.Extra.html#unit"><span class="hs-keyword hs-var hs-var">unit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m () -&gt; m ()
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span class="hs-comment">-- | Monadic generalisation of 'maybe'.</span><span>
</span><span id="line-77"></span><span id="local-6989586621679053348"><span id="local-6989586621679053349"><span id="local-6989586621679053350"><span class="annot"><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-type">maybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053350"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053350"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053349"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053348"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053350"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053349"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053350"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053348"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053350"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053349"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-78"></span><span id="maybeM"><span class="annot"><span class="annottext">maybeM :: m b -&gt; (a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
</span><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-var hs-var">maybeM</span></a></span></span><span> </span><span id="local-6989586621679053151"><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679053151"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679053150"><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679053150"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span id="local-6989586621679053149"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053149"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m b -&gt; (a -&gt; m b) -&gt; Maybe a -&gt; m b
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679053151"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679053150"><span class="hs-identifier hs-var">j</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053149"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-79"></span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="hs-comment">-- | Monadic generalisation of 'fromMaybe'.</span><span>
</span><span id="line-82"></span><span id="local-6989586621679053146"><span id="local-6989586621679053147"><span class="annot"><a href="Control.Monad.Extra.html#fromMaybeM"><span class="hs-identifier hs-type">fromMaybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053147"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053147"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053146"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053147"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053146"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053147"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053146"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-83"></span><span id="fromMaybeM"><span class="annot"><span class="annottext">fromMaybeM :: m a -&gt; m (Maybe a) -&gt; m a
</span><a href="Control.Monad.Extra.html#fromMaybeM"><span class="hs-identifier hs-var hs-var">fromMaybeM</span></a></span></span><span> </span><span id="local-6989586621679053145"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053145"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679053144"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053144"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; (a -&gt; m a) -&gt; m (Maybe a) -&gt; m a
forall (m :: * -&gt; *) b a.
Monad m =&gt;
m b -&gt; (a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
</span><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-var">maybeM</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053145"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053144"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span class="hs-comment">-- | Monadic generalisation of 'either'.</span><span>
</span><span id="line-87"></span><span id="local-6989586621679053140"><span id="local-6989586621679053141"><span id="local-6989586621679053142"><span id="local-6989586621679053143"><span class="annot"><a href="Control.Monad.Extra.html#eitherM"><span class="hs-identifier hs-type">eitherM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053143"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053142"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053143"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053141"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053140"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053143"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053141"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053143"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679053142"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053140"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053143"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053141"><span class="hs-identifier hs-type">c</span></a></span></span></span></span></span><span>
</span><span id="line-88"></span><span id="eitherM"><span class="annot"><span class="annottext">eitherM :: (a -&gt; m c) -&gt; (b -&gt; m c) -&gt; m (Either a b) -&gt; m c
</span><a href="Control.Monad.Extra.html#eitherM"><span class="hs-identifier hs-var hs-var">eitherM</span></a></span></span><span> </span><span id="local-6989586621679053139"><span class="annot"><span class="annottext">a -&gt; m c
</span><a href="#local-6989586621679053139"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679053138"><span class="annot"><span class="annottext">b -&gt; m c
</span><a href="#local-6989586621679053138"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679053137"><span class="annot"><span class="annottext">m (Either a b)
</span><a href="#local-6989586621679053137"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m c) -&gt; (b -&gt; m c) -&gt; Either a b -&gt; m c
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m c
</span><a href="#local-6989586621679053139"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; m c
</span><a href="#local-6989586621679053138"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">(Either a b -&gt; m c) -&gt; m (Either a b) -&gt; m c
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">m (Either a b)
</span><a href="#local-6989586621679053137"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span class="hs-comment">-- | A variant of 'foldM' that has no base case, and thus may only be applied to non-empty lists.</span><span>
</span><span id="line-91"></span><span class="hs-comment">--</span><span>
</span><span id="line-92"></span><span class="hs-comment">-- &gt; fold1M (\x y -&gt; Just x) [] == undefined</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- &gt; fold1M (\x y -&gt; Just $ x + y) [1, 2, 3] == Just 6</span><span>
</span><span id="line-94"></span><span id="local-6989586621679053302"><span id="local-6989586621679053303"><span class="annot"><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier hs-type">fold1M</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Partial.html#Partial"><span class="hs-identifier hs-type">Partial</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053303"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053302"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053302"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053303"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053302"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053302"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053303"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053302"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-95"></span><span id="fold1M"><span class="annot"><span class="annottext">fold1M :: (a -&gt; a -&gt; m a) -&gt; [a] -&gt; m a
</span><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier hs-var hs-var">fold1M</span></a></span></span><span> </span><span id="local-6989586621679053134"><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679053134"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679053133"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053133"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679053132"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053132"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; m a) -&gt; a -&gt; [a] -&gt; m a
forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><span class="hs-identifier hs-var">foldM</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679053134"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053133"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053132"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-96"></span><span class="annot"><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier hs-var">fold1M</span></a></span><span> </span><span id="local-6989586621679053130"><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679053130"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679053129"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053129"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; m a
forall a. HasCallStack =&gt; [Char] -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;fold1M: empty list&quot;</span></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- | Like 'fold1M' but discards the result.</span><span>
</span><span id="line-99"></span><span id="local-6989586621679053126"><span id="local-6989586621679053127"><span class="annot"><a href="Control.Monad.Extra.html#fold1M_"><span class="hs-identifier hs-type">fold1M_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Partial.html#Partial"><span class="hs-identifier hs-type">Partial</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053127"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053126"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053126"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053127"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053126"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053126"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053127"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-100"></span><span id="fold1M_"><span class="annot"><span class="annottext">fold1M_ :: (a -&gt; a -&gt; m a) -&gt; [a] -&gt; m ()
</span><a href="Control.Monad.Extra.html#fold1M_"><span class="hs-identifier hs-var hs-var">fold1M_</span></a></span></span><span> </span><span id="local-6989586621679053125"><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679053125"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679053124"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053124"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; m a) -&gt; [a] -&gt; m a
forall (m :: * -&gt; *) a.
(HasCallStack, Monad m) =&gt;
(a -&gt; a -&gt; m a) -&gt; [a] -&gt; m a
</span><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier hs-var">fold1M</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679053125"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053124"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m () -&gt; m ()
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">() -&gt; m ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span class="hs-comment">-- Data.List for Monad</span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span class="hs-comment">-- | A version of 'partition' that works with a monadic predicate.</span><span>
</span><span id="line-106"></span><span class="hs-comment">--</span><span>
</span><span id="line-107"></span><span class="hs-comment">-- &gt; partitionM (Just . even) [1,2,3] == Just ([2], [1,3])</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- &gt; partitionM (const Nothing) [1,2,3] == Nothing</span><span>
</span><span id="line-109"></span><span id="local-6989586621679053295"><span id="local-6989586621679053296"><span class="annot"><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier hs-type">partitionM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053296"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053295"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053296"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053295"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053296"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053295"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053295"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-110"></span><span id="partitionM"><span class="annot"><span class="annottext">partitionM :: (a -&gt; m Bool) -&gt; [a] -&gt; m ([a], [a])
</span><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier hs-var hs-var">partitionM</span></a></span></span><span> </span><span id="local-6989586621679053123"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053123"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([a], [a]) -&gt; m ([a], [a])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span class="annot"><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier hs-var">partitionM</span></a></span><span> </span><span id="local-6989586621679053122"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053122"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679053121"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053121"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679053120"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053120"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-112"></span><span>    </span><span id="local-6989586621679053119"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053119"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053122"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053121"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-113"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679053118"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053118"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679053117"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053117"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m Bool) -&gt; [a] -&gt; m ([a], [a])
forall (m :: * -&gt; *) a.
Monad m =&gt;
(a -&gt; m Bool) -&gt; [a] -&gt; m ([a], [a])
</span><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier hs-var">partitionM</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053122"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053120"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-114"></span><span>    </span><span class="annot"><span class="annottext">([a], [a]) -&gt; m ([a], [a])
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053121"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053119"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">]</span><span class="annot"><span class="annottext">[a] -&gt; [a] -&gt; [a]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053118"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053121"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053119"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">]</span><span class="annot"><span class="annottext">[a] -&gt; [a] -&gt; [a]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053117"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span class="hs-comment">-- | A version of 'concatMap' that works with a monadic predicate.</span><span>
</span><span id="line-118"></span><span id="local-6989586621679053275"><span id="local-6989586621679053276"><span id="local-6989586621679053277"><span class="annot"><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-identifier hs-type">concatMapM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053277"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053276"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053277"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053275"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053276"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053277"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053275"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-119"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-pragma hs-type">concatMapM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-120"></span><span id="concatMapM"><span class="annot"><span class="annottext">concatMapM :: (a -&gt; m [b]) -&gt; [a] -&gt; m [b]
</span><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-identifier hs-var hs-var">concatMapM</span></a></span></span><span> </span><span id="local-6989586621679053115"><span class="annot"><span class="annottext">a -&gt; m [b]
</span><a href="#local-6989586621679053115"><span class="hs-identifier hs-var">op</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m [b] -&gt; m [b]) -&gt; m [b] -&gt; [a] -&gt; m [b]
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m [b] -&gt; m [b]
</span><a href="#local-6989586621679053113"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-121"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679053113"><span class="annot"><span class="annottext">f :: a -&gt; m [b] -&gt; m [b]
</span><a href="#local-6989586621679053113"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679053112"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053112"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679053111"><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679053111"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679053110"><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679053110"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m [b]
</span><a href="#local-6989586621679053115"><span class="hs-identifier hs-var">op</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053112"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679053110"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679053111"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679053108"><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679053108"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679053111"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">([b] -&gt; m [b]) -&gt; [b] -&gt; m [b]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679053110"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">[b] -&gt; [b] -&gt; [b]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679053108"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="hs-comment">-- | Like 'concatMapM', but has its arguments flipped, so can be used</span><span>
</span><span id="line-124"></span><span class="hs-comment">--   instead of the common @fmap concat $ forM@ pattern.</span><span>
</span><span id="line-125"></span><span id="local-6989586621679053105"><span id="local-6989586621679053106"><span id="local-6989586621679053107"><span class="annot"><a href="Control.Monad.Extra.html#concatForM"><span class="hs-identifier hs-type">concatForM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053107"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053106"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053106"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053107"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053105"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053107"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053105"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-126"></span><span id="concatForM"><span class="annot"><span class="annottext">concatForM :: [a] -&gt; (a -&gt; m [b]) -&gt; m [b]
</span><a href="Control.Monad.Extra.html#concatForM"><span class="hs-identifier hs-var hs-var">concatForM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; m [b]) -&gt; [a] -&gt; m [b]) -&gt; [a] -&gt; (a -&gt; m [b]) -&gt; m [b]
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m [b]) -&gt; [a] -&gt; m [b]
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m [b]) -&gt; [a] -&gt; m [b]
</span><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-identifier hs-var">concatMapM</span></a></span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-comment">-- | A version of 'mconcatMap' that works with a monadic predicate.</span><span>
</span><span id="line-129"></span><span id="local-6989586621679053101"><span id="local-6989586621679053102"><span id="local-6989586621679053103"><span class="annot"><a href="Control.Monad.Extra.html#mconcatMapM"><span class="hs-identifier hs-type">mconcatMapM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053103"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679053102"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053101"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053103"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053102"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053101"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053103"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053102"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-130"></span><span id="mconcatMapM"><span class="annot"><span class="annottext">mconcatMapM :: (a -&gt; m b) -&gt; [a] -&gt; m b
</span><a href="Control.Monad.Extra.html#mconcatMapM"><span class="hs-identifier hs-var hs-var">mconcatMapM</span></a></span></span><span> </span><span id="local-6989586621679053100"><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679053100"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([b] -&gt; b) -&gt; m [b] -&gt; m b
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[b] -&gt; b
forall a. Monoid a =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">mconcat</span></span><span> </span><span class="annot"><span class="annottext">(m [b] -&gt; m b) -&gt; ([a] -&gt; m [b]) -&gt; [a] -&gt; m b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m b) -&gt; [a] -&gt; m [b]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679053100"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="hs-comment">-- | A version of 'mapMaybe' that works with a monadic predicate.</span><span>
</span><span id="line-133"></span><span id="local-6989586621679053095"><span id="local-6989586621679053096"><span id="local-6989586621679053097"><span class="annot"><a href="Control.Monad.Extra.html#mapMaybeM"><span class="hs-identifier hs-type">mapMaybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053097"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053096"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053097"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053095"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053096"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053097"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053095"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-134"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#mapMaybeM"><span class="hs-pragma hs-type">mapMaybeM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-135"></span><span id="mapMaybeM"><span class="annot"><span class="annottext">mapMaybeM :: (a -&gt; m (Maybe b)) -&gt; [a] -&gt; m [b]
</span><a href="Control.Monad.Extra.html#mapMaybeM"><span class="hs-identifier hs-var hs-var">mapMaybeM</span></a></span></span><span> </span><span id="local-6989586621679053094"><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679053094"><span class="hs-identifier hs-var">op</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m [b] -&gt; m [b]) -&gt; m [b] -&gt; [a] -&gt; m [b]
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m [b] -&gt; m [b]
</span><a href="#local-6989586621679053093"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-136"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679053093"><span class="annot"><span class="annottext">f :: a -&gt; m [b] -&gt; m [b]
</span><a href="#local-6989586621679053093"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679053092"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053092"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679053091"><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679053091"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679053090"><span class="annot"><span class="annottext">Maybe b
</span><a href="#local-6989586621679053090"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679053094"><span class="hs-identifier hs-var">op</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053092"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe b
</span><a href="#local-6989586621679053090"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="annot"><span class="annottext">Maybe b
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679053091"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679053089"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679053089"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679053088"><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679053088"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679053091"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">([b] -&gt; m [b]) -&gt; [b] -&gt; m [b]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679053089"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">b -&gt; [b] -&gt; [b]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679053088"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span class="hs-comment">-- Looping</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-comment">-- | A looping operation, where the predicate returns 'Left' as a seed for the next loop</span><span>
</span><span id="line-141"></span><span class="hs-comment">--   or 'Right' to abort the loop.</span><span>
</span><span id="line-142"></span><span class="hs-comment">--</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- &gt; loop (\x -&gt; if x &lt; 10 then Left $ x * 2 else Right $ show x) 1 == &quot;16&quot;</span><span>
</span><span id="line-144"></span><span id="local-6989586621679053257"><span id="local-6989586621679053258"><span class="annot"><a href="Control.Monad.Extra.html#loop"><span class="hs-identifier hs-type">loop</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053258"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679053258"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053257"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053258"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053257"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-145"></span><span id="loop"><span class="annot"><span class="annottext">loop :: (a -&gt; Either a b) -&gt; a -&gt; b
</span><a href="Control.Monad.Extra.html#loop"><span class="hs-identifier hs-var hs-var">loop</span></a></span></span><span> </span><span id="local-6989586621679053087"><span class="annot"><span class="annottext">a -&gt; Either a b
</span><a href="#local-6989586621679053087"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679053086"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053086"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">a -&gt; Either a b
</span><a href="#local-6989586621679053087"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053086"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-146"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679053085"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053085"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Either a b) -&gt; a -&gt; b
forall a b. (a -&gt; Either a b) -&gt; a -&gt; b
</span><a href="Control.Monad.Extra.html#loop"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; Either a b
</span><a href="#local-6989586621679053087"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053085"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-147"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679053084"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679053084"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679053084"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-148"></span><span>
</span><span id="line-149"></span><span class="hs-comment">-- | A monadic version of 'loop', where the predicate returns 'Left' as a seed for the next loop</span><span>
</span><span id="line-150"></span><span class="hs-comment">--   or 'Right' to abort the loop.</span><span>
</span><span id="line-151"></span><span id="local-6989586621679053251"><span id="local-6989586621679053252"><span id="local-6989586621679053253"><span class="annot"><a href="Control.Monad.Extra.html#loopM"><span class="hs-identifier hs-type">loopM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053253"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053252"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053253"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679053252"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053251"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053252"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053253"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053251"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-152"></span><span id="loopM"><span class="annot"><span class="annottext">loopM :: (a -&gt; m (Either a b)) -&gt; a -&gt; m b
</span><a href="Control.Monad.Extra.html#loopM"><span class="hs-identifier hs-var hs-var">loopM</span></a></span></span><span> </span><span id="local-6989586621679053083"><span class="annot"><span class="annottext">a -&gt; m (Either a b)
</span><a href="#local-6989586621679053083"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679053082"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053082"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-153"></span><span>    </span><span id="local-6989586621679053081"><span class="annot"><span class="annottext">Either a b
</span><a href="#local-6989586621679053081"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Either a b)
</span><a href="#local-6989586621679053083"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053082"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-154"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Either a b
</span><a href="#local-6989586621679053081"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-155"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679053080"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053080"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m (Either a b)) -&gt; a -&gt; m b
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m (Either a b)) -&gt; a -&gt; m b
</span><a href="Control.Monad.Extra.html#loopM"><span class="hs-identifier hs-var">loopM</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Either a b)
</span><a href="#local-6989586621679053083"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053080"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-156"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679053079"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679053079"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">b -&gt; m b
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679053079"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-157"></span><span>
</span><span id="line-158"></span><span class="hs-comment">-- | Keep running an operation until it becomes 'False'. As an example:</span><span>
</span><span id="line-159"></span><span class="hs-comment">--</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- whileM $ do sleep 0.1; notM $ doesFileExist &quot;foo.txt&quot;</span><span>
</span><span id="line-162"></span><span class="hs-comment">-- readFile &quot;foo.txt&quot;</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-164"></span><span class="hs-comment">--</span><span>
</span><span id="line-165"></span><span class="hs-comment">--   If you need some state persisted between each test, use 'loopM'.</span><span>
</span><span id="line-166"></span><span id="local-6989586621679053248"><span class="annot"><a href="Control.Monad.Extra.html#whileM"><span class="hs-identifier hs-type">whileM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053248"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053248"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053248"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-167"></span><span id="whileM"><span class="annot"><span class="annottext">whileM :: m Bool -&gt; m ()
</span><a href="Control.Monad.Extra.html#whileM"><span class="hs-identifier hs-var hs-var">whileM</span></a></span></span><span> </span><span id="local-6989586621679053078"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053078"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-168"></span><span>    </span><span id="local-6989586621679053077"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053077"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053078"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-169"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; m () -&gt; m ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053077"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">(m () -&gt; m ()) -&gt; m () -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m ()
forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m ()
</span><a href="Control.Monad.Extra.html#whileM"><span class="hs-identifier hs-var">whileM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053078"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span class="hs-comment">-- | Keep running an operation until it becomes a 'Nothing', accumulating the</span><span>
</span><span id="line-172"></span><span class="hs-comment">--   monoid results inside the 'Just's as the result of the overall loop.</span><span>
</span><span id="line-173"></span><span id="local-6989586621679053074"><span id="local-6989586621679053075"><span class="annot"><a href="Control.Monad.Extra.html#whileJustM"><span class="hs-identifier hs-type">whileJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053075"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679053074"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053075"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053074"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053075"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053074"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-174"></span><span id="whileJustM"><span class="annot"><span class="annottext">whileJustM :: m (Maybe a) -&gt; m a
</span><a href="Control.Monad.Extra.html#whileJustM"><span class="hs-identifier hs-var hs-var">whileJustM</span></a></span></span><span> </span><span id="local-6989586621679053073"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053073"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
</span><a href="#local-6989586621679053072"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">a
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-175"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-176"></span><span>    </span><span id="local-6989586621679053072"><span class="annot"><span class="annottext">go :: a -&gt; m a
</span><a href="#local-6989586621679053072"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679053071"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053071"><span class="hs-identifier hs-var">accum</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-177"></span><span>        </span><span id="local-6989586621679053070"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679053070"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053073"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-178"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679053070"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-179"></span><span>            </span><span class="annot"><span class="annottext">Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053071"><span class="hs-identifier hs-var">accum</span></a></span><span>
</span><span id="line-180"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679053069"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053069"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
</span><a href="#local-6989586621679053072"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m a) -&gt; a -&gt; m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$!</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053071"><span class="hs-identifier hs-var">accum</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053069"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- strict apply, otherwise space leaks</span><span>
</span><span id="line-181"></span><span>
</span><span id="line-182"></span><span class="hs-comment">-- | Keep running an operation until it becomes a 'Just', then return the value</span><span>
</span><span id="line-183"></span><span class="hs-comment">--   inside the 'Just' as the result of the overall loop.</span><span>
</span><span id="line-184"></span><span id="local-6989586621679053241"><span id="local-6989586621679053242"><span class="annot"><a href="Control.Monad.Extra.html#untilJustM"><span class="hs-identifier hs-type">untilJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053242"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053242"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053241"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053242"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053241"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-185"></span><span id="untilJustM"><span class="annot"><span class="annottext">untilJustM :: m (Maybe a) -&gt; m a
</span><a href="Control.Monad.Extra.html#untilJustM"><span class="hs-identifier hs-var hs-var">untilJustM</span></a></span></span><span> </span><span id="local-6989586621679053067"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053067"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-186"></span><span>    </span><span id="local-6989586621679053066"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679053066"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053067"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679053066"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-188"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679053065"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053065"><span class="hs-identifier hs-var">r</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053065"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-189"></span><span>        </span><span class="annot"><span class="annottext">Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Maybe a) -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; m (Maybe a) -&gt; m a
</span><a href="Control.Monad.Extra.html#untilJustM"><span class="hs-identifier hs-var">untilJustM</span></a></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679053067"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-190"></span><span>
</span><span id="line-191"></span><span class="hs-comment">-- Booleans</span><span>
</span><span id="line-192"></span><span>
</span><span id="line-193"></span><span class="hs-comment">-- | Like 'when', but where the test can be monadic.</span><span>
</span><span id="line-194"></span><span id="local-6989586621679053064"><span class="annot"><a href="Control.Monad.Extra.html#whenM"><span class="hs-identifier hs-type">whenM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053064"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053064"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053064"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053064"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-195"></span><span id="whenM"><span class="annot"><span class="annottext">whenM :: m Bool -&gt; m () -&gt; m ()
</span><a href="Control.Monad.Extra.html#whenM"><span class="hs-identifier hs-var hs-var">whenM</span></a></span></span><span> </span><span id="local-6989586621679053063"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053063"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679053062"><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679053062"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m () -&gt; m () -&gt; m ()
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053063"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679053062"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span>
</span><span id="line-197"></span><span class="hs-comment">-- | Like 'unless', but where the test can be monadic.</span><span>
</span><span id="line-198"></span><span id="local-6989586621679053061"><span class="annot"><a href="Control.Monad.Extra.html#unlessM"><span class="hs-identifier hs-type">unlessM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053061"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053061"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053061"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053061"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-199"></span><span id="unlessM"><span class="annot"><span class="annottext">unlessM :: m Bool -&gt; m () -&gt; m ()
</span><a href="Control.Monad.Extra.html#unlessM"><span class="hs-identifier hs-var hs-var">unlessM</span></a></span></span><span> </span><span id="local-6989586621679053060"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053060"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679053059"><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679053059"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m () -&gt; m () -&gt; m ()
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053060"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679053059"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span class="hs-comment">-- | Like @if@, but where the test can be monadic.</span><span>
</span><span id="line-202"></span><span id="local-6989586621679053238"><span id="local-6989586621679053239"><span class="annot"><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-type">ifM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053239"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053239"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053239"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053238"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053239"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053238"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053239"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679053238"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-203"></span><span id="ifM"><span class="annot"><span class="annottext">ifM :: m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var hs-var">ifM</span></a></span></span><span> </span><span id="local-6989586621679053058"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053058"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679053057"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053057"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679053056"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053056"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679053055"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053055"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053058"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679053055"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053057"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679053056"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-204"></span><span>
</span><span id="line-205"></span><span class="hs-comment">-- | Like 'not', but where the test can be monadic.</span><span>
</span><span id="line-206"></span><span id="local-6989586621679053054"><span class="annot"><a href="Control.Monad.Extra.html#notM"><span class="hs-identifier hs-type">notM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679053054"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053054"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053054"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-207"></span><span id="notM"><span class="annot"><span class="annottext">notM :: m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#notM"><span class="hs-identifier hs-var hs-var">notM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool) -&gt; m Bool -&gt; m Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span>
</span><span id="line-208"></span><span>
</span><span id="line-209"></span><span class="hs-comment">-- | The lazy '||' operator lifted to a monad. If the first</span><span>
</span><span id="line-210"></span><span class="hs-comment">--   argument evaluates to 'True' the second argument will not</span><span>
</span><span id="line-211"></span><span class="hs-comment">--   be evaluated.</span><span>
</span><span id="line-212"></span><span class="hs-comment">--</span><span>
</span><span id="line-213"></span><span class="hs-comment">-- &gt; Just True  ||^ undefined  == Just True</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- &gt; Just False ||^ Just True  == Just True</span><span>
</span><span id="line-215"></span><span class="hs-comment">-- &gt; Just False ||^ Just False == Just False</span><span>
</span><span id="line-216"></span><span id="local-6989586621679053226"><span class="annot"><a href="Control.Monad.Extra.html#%7C%7C%5E"><span class="hs-operator hs-type">(||^)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053226"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053226"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053226"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053226"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-217"></span><span id="%7C%7C%5E"><span class="annot"><span class="annottext">||^ :: m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#%7C%7C%5E"><span class="hs-operator hs-var hs-var">(||^)</span></a></span></span><span> </span><span id="local-6989586621679053053"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053053"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679053052"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053052"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053053"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053052"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-218"></span><span>
</span><span id="line-219"></span><span class="hs-comment">-- | The lazy '&amp;&amp;' operator lifted to a monad. If the first</span><span>
</span><span id="line-220"></span><span class="hs-comment">--   argument evaluates to 'False' the second argument will not</span><span>
</span><span id="line-221"></span><span class="hs-comment">--   be evaluated.</span><span>
</span><span id="line-222"></span><span class="hs-comment">--</span><span>
</span><span id="line-223"></span><span class="hs-comment">-- &gt; Just False &amp;&amp;^ undefined  == Just False</span><span>
</span><span id="line-224"></span><span class="hs-comment">-- &gt; Just True  &amp;&amp;^ Just True  == Just True</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- &gt; Just True  &amp;&amp;^ Just False == Just False</span><span>
</span><span id="line-226"></span><span id="local-6989586621679053051"><span class="annot"><a href="Control.Monad.Extra.html#%26%26%5E"><span class="hs-operator hs-type">(&amp;&amp;^)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053051"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053051"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053051"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053051"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-227"></span><span id="%26%26%5E"><span class="annot"><span class="annottext">&amp;&amp;^ :: m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#%26%26%5E"><span class="hs-operator hs-var hs-var">(&amp;&amp;^)</span></a></span></span><span> </span><span id="local-6989586621679053050"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053050"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679053049"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053049"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053050"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679053049"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span class="hs-comment">-- | A version of 'any' lifted to a monad. Retains the short-circuiting behaviour.</span><span>
</span><span id="line-230"></span><span class="hs-comment">--</span><span>
</span><span id="line-231"></span><span class="hs-comment">-- &gt; anyM Just [False,True ,undefined] == Just True</span><span>
</span><span id="line-232"></span><span class="hs-comment">-- &gt; anyM Just [False,False,undefined] == undefined</span><span>
</span><span id="line-233"></span><span class="hs-comment">-- &gt; \(f :: Int -&gt; Maybe Bool) xs -&gt; anyM f xs == orM (map f xs)</span><span>
</span><span id="line-234"></span><span id="local-6989586621679053221"><span id="local-6989586621679053222"><span class="annot"><a href="Control.Monad.Extra.html#anyM"><span class="hs-identifier hs-type">anyM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053222"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053221"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053222"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053221"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053222"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-235"></span><span id="anyM"><span class="annot"><span class="annottext">anyM :: (a -&gt; m Bool) -&gt; [a] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#anyM"><span class="hs-identifier hs-var hs-var">anyM</span></a></span></span><span> </span><span id="local-6989586621679053048"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053048"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m Bool -&gt; m Bool) -&gt; m Bool -&gt; [a] -&gt; m Bool
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#%7C%7C%5E"><span class="hs-operator hs-var">(||^)</span></a></span><span> </span><span class="annot"><span class="annottext">(m Bool -&gt; m Bool -&gt; m Bool)
-&gt; (a -&gt; m Bool) -&gt; a -&gt; m Bool -&gt; m Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053048"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span>
</span><span id="line-237"></span><span class="hs-comment">-- | A version of 'all' lifted to a monad. Retains the short-circuiting behaviour.</span><span>
</span><span id="line-238"></span><span class="hs-comment">--</span><span>
</span><span id="line-239"></span><span class="hs-comment">-- &gt; allM Just [True,False,undefined] == Just False</span><span>
</span><span id="line-240"></span><span class="hs-comment">-- &gt; allM Just [True,True ,undefined] == undefined</span><span>
</span><span id="line-241"></span><span class="hs-comment">-- &gt; \(f :: Int -&gt; Maybe Bool) xs -&gt; anyM f xs == orM (map f xs)</span><span>
</span><span id="line-242"></span><span id="local-6989586621679053046"><span id="local-6989586621679053047"><span class="annot"><a href="Control.Monad.Extra.html#allM"><span class="hs-identifier hs-type">allM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053047"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053046"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053047"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053046"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053047"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-243"></span><span id="allM"><span class="annot"><span class="annottext">allM :: (a -&gt; m Bool) -&gt; [a] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#allM"><span class="hs-identifier hs-var hs-var">allM</span></a></span></span><span> </span><span id="local-6989586621679053045"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053045"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m Bool -&gt; m Bool) -&gt; m Bool -&gt; [a] -&gt; m Bool
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#%26%26%5E"><span class="hs-operator hs-var">(&amp;&amp;^)</span></a></span><span> </span><span class="annot"><span class="annottext">(m Bool -&gt; m Bool -&gt; m Bool)
-&gt; (a -&gt; m Bool) -&gt; a -&gt; m Bool -&gt; m Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053045"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-244"></span><span>
</span><span id="line-245"></span><span class="hs-comment">-- | A version of 'or' lifted to a monad. Retains the short-circuiting behaviour.</span><span>
</span><span id="line-246"></span><span class="hs-comment">--</span><span>
</span><span id="line-247"></span><span class="hs-comment">-- &gt; orM [Just False,Just True ,undefined] == Just True</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- &gt; orM [Just False,Just False,undefined] == undefined</span><span>
</span><span id="line-249"></span><span class="hs-comment">-- &gt; \xs -&gt; Just (or xs) == orM (map Just xs)</span><span>
</span><span id="line-250"></span><span id="local-6989586621679053044"><span class="annot"><a href="Control.Monad.Extra.html#orM"><span class="hs-identifier hs-type">orM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053044"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053044"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053044"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-251"></span><span id="orM"><span class="annot"><span class="annottext">orM :: [m Bool] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#orM"><span class="hs-identifier hs-var hs-var">orM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(m Bool -&gt; m Bool) -&gt; [m Bool] -&gt; m Bool
forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#anyM"><span class="hs-identifier hs-var">anyM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-252"></span><span>
</span><span id="line-253"></span><span class="hs-comment">-- | A version of 'and' lifted to a monad. Retains the short-circuiting behaviour.</span><span>
</span><span id="line-254"></span><span class="hs-comment">--</span><span>
</span><span id="line-255"></span><span class="hs-comment">-- &gt; andM [Just True,Just False,undefined] == Just False</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- &gt; andM [Just True,Just True ,undefined] == undefined</span><span>
</span><span id="line-257"></span><span class="hs-comment">-- &gt; \xs -&gt; Just (and xs) == andM (map Just xs)</span><span>
</span><span id="line-258"></span><span id="local-6989586621679053043"><span class="annot"><a href="Control.Monad.Extra.html#andM"><span class="hs-identifier hs-type">andM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053043"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053043"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053043"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-259"></span><span id="andM"><span class="annot"><span class="annottext">andM :: [m Bool] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#andM"><span class="hs-identifier hs-var hs-var">andM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(m Bool -&gt; m Bool) -&gt; [m Bool] -&gt; m Bool
forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#allM"><span class="hs-identifier hs-var">allM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-260"></span><span>
</span><span id="line-261"></span><span class="hs-comment">-- Searching</span><span>
</span><span id="line-262"></span><span>
</span><span id="line-263"></span><span class="hs-comment">-- | Like 'find', but where the test can be monadic.</span><span>
</span><span id="line-264"></span><span class="hs-comment">--</span><span>
</span><span id="line-265"></span><span class="hs-comment">-- &gt; findM (Just . isUpper) &quot;teST&quot;             == Just (Just 'S')</span><span>
</span><span id="line-266"></span><span class="hs-comment">-- &gt; findM (Just . isUpper) &quot;test&quot;             == Just Nothing</span><span>
</span><span id="line-267"></span><span class="hs-comment">-- &gt; findM (Just . const True) [&quot;x&quot;,undefined] == Just (Just &quot;x&quot;)</span><span>
</span><span id="line-268"></span><span id="local-6989586621679053041"><span id="local-6989586621679053042"><span class="annot"><a href="Control.Monad.Extra.html#findM"><span class="hs-identifier hs-type">findM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053042"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053041"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053042"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053041"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053042"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053041"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-269"></span><span id="findM"><span class="annot"><span class="annottext">findM :: (a -&gt; m Bool) -&gt; [a] -&gt; m (Maybe a)
</span><a href="Control.Monad.Extra.html#findM"><span class="hs-identifier hs-var hs-var">findM</span></a></span></span><span> </span><span id="local-6989586621679053040"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053040"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m (Maybe a) -&gt; m (Maybe a))
-&gt; m (Maybe a) -&gt; [a] -&gt; m (Maybe a)
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679053039"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053039"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m (Maybe a) -&gt; m (Maybe a) -&gt; m (Maybe a)
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679053040"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053039"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; m (Maybe a)) -&gt; Maybe a -&gt; m (Maybe a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053039"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-270"></span><span>
</span><span id="line-271"></span><span class="hs-comment">-- | Like 'findM', but also allows you to compute some additional information in the predicate.</span><span>
</span><span id="line-272"></span><span id="local-6989586621679053212"><span id="local-6989586621679053213"><span id="local-6989586621679053214"><span class="annot"><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier hs-type">firstJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679053214"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679053213"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053214"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053212"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679053213"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679053214"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679053212"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-273"></span><span id="firstJustM"><span class="annot"><span class="annottext">firstJustM :: (a -&gt; m (Maybe b)) -&gt; [a] -&gt; m (Maybe b)
</span><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier hs-var hs-var">firstJustM</span></a></span></span><span> </span><span id="local-6989586621679053038"><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679053038"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe b -&gt; m (Maybe b)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe b
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-274"></span><span class="annot"><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier hs-var">firstJustM</span></a></span><span> </span><span id="local-6989586621679053037"><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679053037"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679053036"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053036"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679053035"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053035"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (Maybe b) -&gt; (b -&gt; m (Maybe b)) -&gt; m (Maybe b) -&gt; m (Maybe b)
forall (m :: * -&gt; *) b a.
Monad m =&gt;
m b -&gt; (a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
</span><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-var">maybeM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; m (Maybe b)) -&gt; [a] -&gt; m (Maybe b)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m (Maybe b)) -&gt; [a] -&gt; m (Maybe b)
</span><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier hs-var">firstJustM</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679053037"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679053035"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe b -&gt; m (Maybe b)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Maybe b -&gt; m (Maybe b)) -&gt; (b -&gt; Maybe b) -&gt; b -&gt; m (Maybe b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; Maybe b
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679053037"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679053036"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-275"></span></pre></body></html>